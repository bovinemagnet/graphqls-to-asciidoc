
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>graphqls-to-asciidoc: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bovinemagnet/graphqls-to-asciidoc/main.go (12.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "regexp"
        "runtime"
        "sort"
        "strings"
        "text/template"
        "time"
        "unicode"

        "github.com/vektah/gqlparser/v2/ast"
        "github.com/vektah/gqlparser/v2/parser"
)

var (
        Version   = "development"
        BuildTime = "unknown"
)

var excludeInternal = flag.Bool("exclude-internal", false, "Exclude internal queries from output")
var schemaFile = flag.String("schema", "", "Path to the GraphQL schema file")
var includeMutations = flag.Bool("mutations", true, "Include mutations in the output")
var includeQueries = flag.Bool("queries", true, "Include queries in the output")
var includeSubscriptions = flag.Bool("subscriptions", false, "Include subscriptions in the output")
var includeDirectives = flag.Bool("directives", true, "Include directives in the output")
var includeTypes = flag.Bool("types", true, "Include types in the output")
var includeEnums = flag.Bool("enums", true, "Include enums in the output")
var includeInputs = flag.Bool("inputs", true, "Include inputs in the output")
var includeScalars = flag.Bool("scalars", true, "Include scalars in the output")

var showVersion = flag.Bool("version", false, "Show program version and build information")

var fieldTemplate = `
| {{.Type}} | {{.Name}} | {{processDescription .Description}}
{{- if .RequiredOrArray}}

.Notes:
{{- end}}
{{- if .Required}}

.Required:
* {{.Required}}
{{- end}}
{{- if .IsArray}}
.Array:
* True
{{- end}}
{{- if .Directives}}

.Directives:
{{.Directives}}
{{- end }}
{{- if .Changelog}}
{{.Changelog}}
{{- end }}
`

const scalarTemplate = `
// tag::scalar[]
[[scalars]]
{{.ScalarTag}}

GraphQL specifies a basic set of well-defined Scalar types: Int, Float, String, Boolean, and ID.
{{- if .FoundScalars }}

The following custom scalar types are defined in this schema:

{{- range .Scalars }}
// tag::scalar-{{.Name}}[]
[[scalar-{{.Name}}]]
=== {{.Name}}

{{- if .Description }}

// tag::scalar-description-{{.Name}}[]
{{ .Description | printAsciiDocTagsTmpl }}
// end::scalar-description-{{.Name}}[]

{{ end }}
// end::scalar-{{.Name}}[]

{{ end }}
{{- else }}
[NOTE]
====
No custom scalars exist in this schema.
====
{{ end }}
// end::scalar[]
`

const subscriptionTemplate = `
// tag::subscription[]
== Subscription

{{- if .FoundSubscriptions }}
{{- range .Subscriptions }}
{{- if .Description }}
{{ .Description | printAsciiDocTagsTmpl }}
{{ end }}

{{ .Details }}

{{ end }}
{{- else }}
[NOTE]
====
No subscriptions exist in this schema.
====
{{ end }}
// end::subscription[]
`

const mutationTemplate = `
// tag::mutation[]
[[mutations]]
{{.MutationTag}}

{{- if .MutationObjectDescription }}
{{ .MutationObjectDescription | printAsciiDocTagsTmpl }}
{{- end }}

GraphQL Mutations are entry points on a GraphQL server that provides write access to our data sources.

{{- if .FoundMutations }}

{{- range .Mutations }}
// tag::mutation-{{.Name}}[]
[[{{.AnchorName}}]]
// tag::method-signature-{{.Name}}[]
=== {{.Name}}{{ if .IsInternal }} [INTERNAL]{{ end }}
// end::method-signature-{{.Name}}[]

// tag::method-description-{{.Name}}[]
{{- if .CleanedDescription }}
{{ .CleanedDescription | printAsciiDocTagsTmpl }}
{{- end }}
// end::method-description-{{.Name}}[]

{{ .MethodSignatureBlock }}

// tag::method-args-{{.Name}}[]
{{ convertDescriptionToRefNumbers .Description true }}
// end::method-args-{{.Name}}[]

// tag::mutation-name-{{.Name}}[]
*Mutation Name:* _{{ .Name }}_
// end::mutation-name-{{.Name}}[]

// tag::mutation-return-{{.Name}}[]
*Return:* {{ .TypeName }}
// end::mutation-return-{{.Name}}[]

{{- if .HasArguments }}
// tag::arguments-{{.Name}}[]
.Arguments
{{ .Arguments }}
// end::arguments-{{.Name}}[]
{{- end }}

{{- if .HasDirectives }}
// tag::mutation-directives-{{.Name}}[]
.Directives
{{ .Directives }}
// end::mutation-directives-{{.Name}}[]
{{- end }}

{{- if .Changelog }}
// tag::mutation-changelog-{{.Name}}[]
{{ .Changelog }}
// end::mutation-changelog-{{.Name}}[]
{{- end }}

// end::mutation-{{.Name}}[]
{{ end }}
{{- else }}
[NOTE]
====
No mutations exist in this schema.
====
{{ end }}
// end::mutation[]
`

// Add this template constant
const typeSectionTemplate = `
{{.TypesTag}}
{{range .Types}}
// tag::type-{{.Name}}[]
[[{{.AnchorName}}]]
=== {{.Name}}

{{- if .Description }}
// tag::type-description-{{.Name}}[]
{{ .Description | printAsciiDocTagsTmpl }}
// end::type-description-{{.Name}}[]
{{- end }}

{{- if .Changelog }}
// tag::type-changelog-{{.Name}}[]
{{ .Changelog }}
// end::type-changelog-{{.Name}}[]
{{- end }}

{{ .FieldsTable }}

// end::type-{{.Name}}[]

{{end}}
`

const enumSectionTemplate = `
{{.EnumsTag}}
{{range .Enums}}
// tag::enum-def-{{.Name}}[]
[[{{.AnchorName}}]]

=== {{.Name}}

{{- if .Description }}
// tag::enum-description-{{.Name}}[]
{{ .Description | printAsciiDocTagsTmpl }}
// end::enum-description-{{.Name}}[]
{{- end }}

{{ .ValuesTable }}

// end::enum-def-{{.Name}}[]

{{end}}
`

const directiveSectionTemplate = `
{{.DirectivesTag}}
{{- if .FoundDirectives }}

{{ .TableOptions }}
|===
| Directive | Arguments | Description
{{- range .Directives }}
| @{{.Name}} | {{.Arguments}} | {{.Description}}
{{- end }}
|===

{{- else }}
[NOTE]
====
No custom directives exist in this schema.
====
{{- end }}
`

const inputSectionTemplate = `
{{.InputsTag}}
{{range .Inputs}}
// tag::input-def-{{.Name}}[]
[[{{.AnchorName}}]]

=== {{.Name}}

{{- if .Description }}
// tag::input-description-{{.Name}}[] // Using generic description tags
{{ .Description | printAsciiDocTagsTmpl }}
// end::input-description-{{.Name}}[]
{{- end }}

{{- if .Changelog }}
// tag::input-changelog-{{.Name}}[]
{{ .Changelog }}
// end::input-changelog-{{.Name}}[]
{{- end }}

{{ .FieldsTable }}

// end::input-def-{{.Name}}[]

{{end}}
`

const (
        // include tags
        includeAdocLineTags = true
        // AsciiDoc tags
        CROSS_REF      = "[[%s]]\n"
        L2_TAG         = "== %s\n\n"
        L3_TAG         = "=== %s\n\n"
        TYPES_TAG      = "== Types\n"
        ENUM_TAG       = "== Enumerations\n"
        INPUT_TAG      = "== Inputs\n"
        DIRECTIVES_TAG = "== Directives\n"
        SCALAR_TAG     = "== Scalars\n"

        ADOC_INPUT_DEF_START_TAG = "// tag::input-def-%s[]\n"
        ADOC_INPUT_DEF_END_TAG   = "// end::input-def-%s[]\n"
        ADOC_INPUT_START_TAG     = "// tag::input-%s[]\n"
        ADOC_INPUT_END_TAG       = "// end::input-%s[]\n"

        ADOC_NODE_START_TAG = "// tag::node-%s[]\n"
        ADOC_NODE_END_TAG   = "// end::node-%s[]\n"

        ADOC_QUERY_START_TAG = "// tag::query-%s[]\n"
        ADOC_QUERY_END_TAG   = "// end::query-%s[]\n"

        ADOC_ARGUMENTS_START_TAG = "// tag::arguments-%s[]\n"
        ADOC_ARGUMENTS_END_TAG   = "// end::arguments-%s[]\n"

        ADOC_ENUM_START_TAG      = "// tag::enum-%s[]\n"
        ADOC_ENUM_END_TAG        = "// end::enum-%s[]\n"
        ADOC_ENUM_DEF_START_TAG  = "// tag::enum-def-%s[]\n"
        ADOC_ENUM_DEF_END_TAG    = "// end::enum-def-%s[]\n"
        ADOC_ENUM_DESC_START_TAG = "// tag::enum-description-%s[]\n"
        ADOC_ENUM_DESC_END_TAG   = "// end::enum-description-%s[]\n"

        ADOC_SCALAR_SEC_START_TAG  = "// tag::scalar[]\n"
        ADOC_SCALAR_SEC_END_TAG    = "// end::scalar[]\n"
        ADOC_SCALAR_START_TAG      = "// tag::scalar-%s[]\n"
        ADOC_SCALAR_END_TAG        = "// end::scalar-%s[]\n"
        ADOC_SCALAR_DESC_START_TAG = "// tag::scalar-description-%s[]\n"
        ADOC_SCALAR_DESC_END_TAG   = "// end::scalar-description-%s[]\n"

        ADOC_METHOD_SIG_START_TAG  = "// tag::method-signature-%s[]\n"
        ADOC_METHOD_SIG_END_TAG    = "// end::method-signature-%s[]\n"
        ADOC_METHOD_DESC_START_TAG = "// tag::method-description-%s[]\n"
        ADOC_METHOD_DESC_END_TAG   = "// end::method-description-%s[]\n"
        ADOC_METHOD_ARGS_START_TAG = "// tag::method-args-%s[]\n"
        ADOC_METHOD_ARGS_END_TAG   = "// end::method-args-%s[]\n"

        ADOC_MUTATION_START_TAG      = "// tag::mutation-%s[]\n"
        ADOC_MUTATION_END_TAG        = "// end::mutation-%s[]\n"
        ADOC_MUTATION_DESC_START_TAG = "// tag::mutation-description-%s[]\n"
        ADOC_MUTATION_DESC_END_TAG   = "// end::mutation-description-%s[]\n"
        ADOC_MUTATION_ARGS_START_TAG = "// tag::mutation-args-%s[]\n"
        ADOC_MUTATION_ARGS_END_TAG   = "// end::mutation-args-%s[]\n"

        ADOC_SUBSCRIPTION_START_TAG      = "// tag::subscription-%s[]\n"
        ADOC_SUBSCRIPTION_END_TAG        = "// end::subscription-%s[]\n"
        ADOC_SUBSCRIPTION_DESC_START_TAG = "// tag::subscription-description-%s[]\n"
        ADOC_SUBSCRIPTION_DESC_END_TAG   = "// end::subscription-description-%s[]\n"
        ADOC_SUBSCRIPTION_ARGS_START_TAG = "// tag::subscription-args-%s[]\n"
        ADOC_SUBSCRIPTION_ARGS_END_TAG   = "// end::subscription-args-%s[]\n"

        ADOC_TYPE_START_TAG           = "// tag::type-%s[]\n"
        ADOC_TYPE_END_TAG             = "// end::type-%s[]\n"
        ADOC_TYPE_DESC_START_TAG      = "// tag::type-description-%s[]\n"
        ADOC_TYPE_DESC_END_TAG        = "// end::type-description-%s[]\n"
        ADOC_TYPE_DEF_START_TAG       = "// tag::type-def-%s[]\n"
        ADOC_TYPE_DEF_END_TAG         = "// end::type-def-%s[]\n"
        ADOC_TYPE_DIRECTIVE_START_TAG = "// tag::type-directive-%s[]\n"
        ADOC_TYPE_DIRECTIVE_END_TAG   = "// end::type-directive-%s[]\n"
        TABLE_SE                      = "|==="

        SOURCE_HEAD = "[source, kotlin]\n"

        TABLE_OPTIONS_2 = "[width=\"90%\", cols=\"2a,6a\" options=\"header\" orientation=\"landscape\" grid=\"none\" stripes=\"even\"  , frame=\"topbot\"]"
        TABLE_OPTIONS_3 = "[width=\"90%\", cols=\"2a,2a,6a\" options=\"header\" orientation=\"landscape\" grid=\"none\" stripes=\"even\" , frame=\"topbot\"]"
        TABLE_OPTIONS_4 = "[width=\"90%\", cols=\"2a,5a,6a,4a\" options=\"header\" orientation=\"landscape\" grid=\"none\" stripes=\"even\" , frame=\"topbot\"]"
        TABLE_OPTIONS_5 = "[width=\"90%\", cols=\"2a,2a,4a,4a\" options=\"header\" orientation=\"landscape\" grid=\"none\" stripes=\"even\" , frame=\"topbot\"]"
)

type FieldData struct {
        Type            string
        Name            string
        Description     string
        RequiredOrArray bool
        Required        string
        IsArray         bool
        Directives      string
        Changelog       string
}

type ScalarData struct {
        ScalarTag    string
        FoundScalars bool
        Scalars      []Scalar
}

type Scalar struct {
        Name        string
        Description string
        CrossRef    string
        L3Tag       string
}

type SubscriptionData struct {
        FoundSubscriptions bool
        Subscriptions      []Subscription
}

type Subscription struct {
        Description string
        Details     string
}

func init() <span class="cov1" title="1">{
        template.Must(template.New("field").Funcs(template.FuncMap{
                "processDescription": processDescription,
        }).Parse(fieldTemplate))
}</span>

type MutationData struct {
        Mutations                 []Mutation
        MutationObjectDescription string
        FoundMutations            bool
        MutationTag               string
}

type Mutation struct {
        Name                 string
        Description          string
        CleanedDescription   string
        TypeName             string
        Arguments            string
        Directives           string
        HasArguments         bool
        HasDirectives        bool
        AnchorName           string
        IsInternal           bool
        MethodSignatureBlock string
        Changelog            string
}

// Add these structs
type TypeSectionData struct {
        TypesTag string
        Types    []TypeInfo
}

type TypeInfo struct {
        Name        string
        Kind        string // "Object" or "Interface"
        AnchorName  string
        Description string
        FieldsTable string // Pre-rendered AsciiDoc table for fields
        IsInterface bool
        Changelog   string
}

// Add these structs
type DirectiveSectionData struct {
        DirectivesTag   string
        FoundDirectives bool
        Directives      []DirectiveInfo
        TableOptions    string // Added field for table options
}

type DirectiveInfo struct {
        Name        string
        Arguments   string // Pre-formatted arguments string
        Description string
}

// Add these structs
type EnumSectionData struct {
        EnumsTag string
        Enums    []EnumInfo
}

type EnumInfo struct {
        Name        string
        AnchorName  string
        Description string
        ValuesTable string // Pre-rendered AsciiDoc table for values
}

// Add these structs
type InputSectionData struct {
        InputsTag string
        Inputs    []InputInfo
}

type InputInfo struct {
        Name        string
        AnchorName  string
        Description string
        FieldsTable string // Pre-rendered AsciiDoc table for fields
        Changelog   string
}

func main() <span class="cov0" title="0">{

        // Parse command-line flags
        flag.Parse()

        // Handle version flag
        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("graphqls-to-asciidoc\n")
                fmt.Printf("Version: %s\n", Version)
                fmt.Printf("Build Time: %s\n", BuildTime)
                fmt.Printf("Built with: %s\n", runtime.Version())
                os.Exit(0)
        }</span>

        // Check if schema file is provided
        <span class="cov0" title="0">if *schemaFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: -schema flag is required\n")
                flag.Usage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">b, err := os.ReadFile(*schemaFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to read schema file %s: %v", *schemaFile, err)
        }</span>

        <span class="cov0" title="0">source := &amp;ast.Source{
                Name:  "GraphQL schema",
                Input: string(b),
        }

        doc, gqlErr := parser.ParseSchema(source)
        if gqlErr != nil </span><span class="cov0" title="0">{
                log.Fatal(gqlErr)
        }</span>

        <span class="cov0" title="0">definitionsMap := make(map[string]*ast.Definition)
        for _, def := range doc.Definitions </span><span class="cov0" title="0">{
                definitionsMap[def.Name] = def
        }</span>

        // Sort definitions by name
        <span class="cov0" title="0">sortedDefs := make([]*ast.Definition, len(doc.Definitions))
        copy(sortedDefs, doc.Definitions)
        sort.Slice(sortedDefs, func(i, j int) bool </span><span class="cov0" title="0">{
                return sortedDefs[i].Name &lt; sortedDefs[j].Name
        }</span>)

        // Print heading and current time
        <span class="cov0" title="0">fmt.Println("= GraphQL Documentation")
        fmt.Println(":toc: left")
        fmt.Printf(":revdate: %s\n", time.Now().Format(time.RFC1123))
        fmt.Printf(":commandline: %s\n", strings.Join(os.Args, " "))
        fmt.Printf(":sourceFile: %s\n", *schemaFile)
        fmt.Println(":reproducible:")
        fmt.Println(":page-partial:")
        fmt.Println(":sect-anchors:")
        fmt.Println(":table-caption!:")
        fmt.Println(":table-stripes: even")

        fmt.Println(":pdf-page-size: A4")
        fmt.Println(":tags: api, GraphQL, nodes, types, query")

        fmt.Print("\n\n")

        fmt.Println("[IMPORTANT]")
        fmt.Println("====")
        fmt.Printf("This is automatically generated from the schema file `%s`. +\n", *schemaFile)
        fmt.Println("Do not edit this file directly. +")
        fmt.Println("Last generated _{revdate}_")
        fmt.Println("====")
        // Add a blank line.
        fmt.Println()

        if *includeQueries </span><span class="cov0" title="0">{
                printQueries(sortedDefs, definitionsMap)
                fmt.Println()
        }</span>

        <span class="cov0" title="0">if *includeMutations </span><span class="cov0" title="0">{
                //printMutations(sortedDefs, definitionsMap)
                printMutationsTmpl(sortedDefs, definitionsMap)
                fmt.Println()
        }</span>

        <span class="cov0" title="0">if *includeSubscriptions </span><span class="cov0" title="0">{
                //printSubscriptions(sortedDefs, definitionsMap)
                printSubscriptionsTmpl(sortedDefs, definitionsMap)
                fmt.Println()
        }</span>

        <span class="cov0" title="0">if *includeTypes </span><span class="cov0" title="0">{
                //printTypes(sortedDefs, definitionsMap) // Comment out the old call
                printTypesTmpl(sortedDefs, definitionsMap) // Add the new call
                fmt.Println()
        }</span>

        <span class="cov0" title="0">if *includeEnums </span><span class="cov0" title="0">{
                // printEnums(sortedDefs, definitionsMap) // Comment out old call
                printEnumsTmpl(sortedDefs, definitionsMap) // Add new call
                fmt.Println()
        }</span>

        <span class="cov0" title="0">if *includeInputs </span><span class="cov0" title="0">{

                // printInputs(sortedDefs, definitionsMap) // Comment out old call
                printInputsTmpl(sortedDefs, definitionsMap) // Add new call
                fmt.Println()
        }</span>
        <span class="cov0" title="0">if *includeDirectives </span><span class="cov0" title="0">{
                // Add directives documentation
                // printDirectives(doc) // Comment out the old call
                printDirectivesTmpl(doc) // Add the new call
                fmt.Println()
        }</span>

        <span class="cov0" title="0">if *includeScalars </span><span class="cov0" title="0">{
                //printScalars(sortedDefs, definitionsMap) // Add this line
                printScalarsTmpl(sortedDefs, definitionsMap)
                fmt.Println()
        }</span>
}

/**
 * Print the type details
 */
func printTypesTmpl(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        var typeInfos []TypeInfo

        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                // Include Objects (except Query) and Interfaces
                if (t.Kind == ast.Object &amp;&amp; t.Name != "Query") || t.Kind == ast.Interface </span><span class="cov0" title="0">{

                        fieldsTableString, err := getTypeFieldsTableString(t, definitionsMap)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error generating fields table for type %s: %v\n", t.Name, err)
                                // Decide if you want to skip this type or continue with an empty table
                                fieldsTableString = "[ERROR generating fields table]"
                        }</span>

                        // Process type description and extract changelog
                        <span class="cov0" title="0">processedDesc, changelog := processDescriptionWithChangelog(t.Description)

                        typeInfo := TypeInfo{
                                Name:        t.Name,
                                Kind:        string(t.Kind),
                                AnchorName:  "type_" + camelToSnake(t.Name), // Use type_ prefix consistently
                                Description: processedDesc,
                                FieldsTable: fieldsTableString,
                                IsInterface: t.Kind == ast.Interface,
                                Changelog:   changelog,
                        }
                        typeInfos = append(typeInfos, typeInfo)</span>
                }
        }

        <span class="cov0" title="0">data := TypeSectionData{
                TypesTag: TYPES_TAG, // Use existing constant
                Types:    typeInfos,
        }

        funcMap := template.FuncMap{
                "printAsciiDocTagsTmpl": printAsciiDocTagsTmpl,
        }

        tmpl, err := template.New("typeSectionTemplate").Funcs(funcMap).Parse(typeSectionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error parsing type section template: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(os.Stdout, data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error executing type section template: %v\n", err)
        }</span>
}

func processDescription(description string) string <span class="cov5" title="8">{
        // First convert markdown code blocks to AsciiDoc format
        processed := convertMarkdownCodeBlocks(description)

        // Format @deprecated directives with backticks if not already enclosed
        processed = formatDeprecatedDirectives(processed)

        // Replace * and - with newline followed by the character, but only when they start list items
        // Use regex to replace asterisks only when they start list items
        reAsterisk := regexp.MustCompile(`(^|\s)\*\s`)
        processed = reAsterisk.ReplaceAllString(processed, "${1}* ")

        // Use regex to replace hyphens only when they start list items
        // Match: start of line OR whitespace, followed by hyphen, followed by space
        reHyphen := regexp.MustCompile(`(^|\s)-\s`)
        processed = reHyphen.ReplaceAllString(processed, "${1}* ")

        // Remove any double newlines that might have been created
        //processed = strings.ReplaceAll(processed, "\n\n", "\n")
        // Remove newline at start if present
        return strings.TrimPrefix(processed, "\n")
}</span>

// formatDeprecatedDirectives wraps @deprecated directives in backticks if not already enclosed
func formatDeprecatedDirectives(description string) string <span class="cov6" title="14">{
        // Regex to match @deprecated directives with optional arguments
        re := regexp.MustCompile(`@deprecated(?:\([^)]*\))?`)

        return re.ReplaceAllStringFunc(description, func(match string) string </span><span class="cov5" title="8">{
                // Check if the match is already surrounded by backticks by examining the context
                matchIndex := strings.Index(description, match)
                if matchIndex &gt; 0 &amp;&amp; description[matchIndex-1] == '`' </span><span class="cov1" title="1">{
                        // Check if there's a closing backtick after the match
                        endIndex := matchIndex + len(match)
                        if endIndex &lt; len(description) &amp;&amp; description[endIndex] == '`' </span><span class="cov1" title="1">{
                                return match // Already enclosed in backticks
                        }</span>
                }

                // Not already in backticks, so wrap it
                <span class="cov5" title="7">return "`" + match + "`"</span>
        })
}

// convertMarkdownCodeBlocks converts markdown code blocks (```lang) to AsciiDoc format ([source,lang] ----)
func convertMarkdownCodeBlocks(description string) string <span class="cov6" title="12">{
        // Regex to match markdown code blocks: ```language\ncontent\n```
        // Supports optional language specification
        re := regexp.MustCompile("(?s)```(\\w*)\n(.*?)\n```")

        return re.ReplaceAllStringFunc(description, func(match string) string </span><span class="cov4" title="5">{
                // Extract language and content from the match
                submatches := re.FindStringSubmatch(match)
                if len(submatches) &lt; 3 </span><span class="cov0" title="0">{
                        return match // Return original if parsing fails
                }</span>

                <span class="cov4" title="5">language := submatches[1]
                content := submatches[2]

                // Default to generic source block if no language specified
                if language == "" </span><span class="cov1" title="1">{
                        language = "text"
                }</span>

                // Convert to AsciiDoc format
                <span class="cov4" title="5">return fmt.Sprintf("[source,%s]\n----\n%s\n----", language, content)</span>
        })
}

// extractChangelog extracts version annotations and formats them as AsciiDoc changelog
func extractChangelog(description string) string <span class="cov5" title="8">{
        // Regex to match version annotations: action.version: version_number
        re := regexp.MustCompile(`(?m)^\s*(add|update|deprecated|removed)\.version:\s*(.+)$`)
        matches := re.FindAllStringSubmatch(description, -1)

        if len(matches) == 0 </span><span class="cov3" title="3">{
                return ""
        }</span>

        // Group versions by action type
        <span class="cov4" title="5">changelog := map[string][]string{
                "add":        {},
                "update":     {},
                "deprecated": {},
                "removed":    {},
        }

        for _, match := range matches </span><span class="cov6" title="11">{
                if len(match) &gt;= 3 </span><span class="cov6" title="11">{
                        action := match[1]
                        version := strings.TrimSpace(match[2])
                        if _, exists := changelog[action]; exists </span><span class="cov6" title="11">{
                                changelog[action] = append(changelog[action], version)
                        }</span>
                }
        }

        // Build AsciiDoc changelog
        <span class="cov4" title="5">var changelogBuilder strings.Builder
        changelogBuilder.WriteString("\n.Changelog\n")

        // Order: add, update, deprecated, removed
        actions := []string{"add", "update", "deprecated", "removed"}
        for _, action := range actions </span><span class="cov7" title="20">{
                versions := changelog[action]
                if len(versions) &gt; 0 </span><span class="cov5" title="10">{
                        if len(versions) == 1 </span><span class="cov5" title="9">{
                                changelogBuilder.WriteString(fmt.Sprintf("* %s: %s\n", action, versions[0]))
                        }</span> else<span class="cov1" title="1"> {
                                changelogBuilder.WriteString(fmt.Sprintf("* %s: %s\n", action, strings.Join(versions, ", ")))
                        }</span>
                }
        }

        <span class="cov4" title="5">return changelogBuilder.String()</span>
}

// processDescriptionWithChangelog processes description and extracts changelog separately
func processDescriptionWithChangelog(description string) (processedDesc, changelog string) <span class="cov3" title="3">{
        // Extract changelog first
        changelog = extractChangelog(description)

        // Remove version annotations from description for regular processing
        versionRe := regexp.MustCompile(`(?m)^\s*(add|update|deprecated|removed)\.version:\s*.+$\n?`)
        cleanedDesc := versionRe.ReplaceAllString(description, "")

        // Process the cleaned description normally
        processedDesc = processDescription(cleanedDesc)

        return processedDesc, changelog
}</span>

/**
 * Print the enumeration details
 */
func printEnumsTmpl(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        var enumInfos []EnumInfo

        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                if t.Kind == ast.Enum </span><span class="cov0" title="0">{
                        valuesTableString := getEnumValuesTableString(t)

                        enumInfo := EnumInfo{
                                Name:        t.Name,
                                AnchorName:  camelToSnake(t.Name), // Anchor name for enum
                                Description: t.Description,
                                ValuesTable: valuesTableString,
                        }
                        enumInfos = append(enumInfos, enumInfo)
                }</span>
        }

        <span class="cov0" title="0">data := EnumSectionData{
                EnumsTag: ENUM_TAG, // Use existing constant
                Enums:    enumInfos,
        }

        funcMap := template.FuncMap{
                "printAsciiDocTagsTmpl": printAsciiDocTagsTmpl,
        }

        tmpl, err := template.New("enumSectionTemplate").Funcs(funcMap).Parse(enumSectionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error parsing enum section template: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(os.Stdout, data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error executing enum section template: %v\n", err)
        }</span>
}

func printInputsTmpl(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        var inputInfos []InputInfo

        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                if t.Kind == ast.InputObject </span><span class="cov0" title="0">{

                        fieldsTableString, err := getInputFieldsTableString(t, definitionsMap)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log error but potentially continue?
                                fmt.Fprintf(os.Stderr, "Error generating fields table for input %s: %v\n", t.Name, err)
                                fieldsTableString = "[ERROR generating fields table]"
                        }</span>

                        // Process input description and extract changelog
                        <span class="cov0" title="0">processedDesc, changelog := processDescriptionWithChangelog(t.Description)

                        inputInfo := InputInfo{
                                Name:        t.Name,
                                AnchorName:  "input_" + camelToSnake(t.Name), // Use input_ prefix
                                Description: processedDesc,
                                FieldsTable: fieldsTableString,
                                Changelog:   changelog,
                        }
                        inputInfos = append(inputInfos, inputInfo)</span>
                }
        }

        <span class="cov0" title="0">data := InputSectionData{
                InputsTag: INPUT_TAG, // Use existing constant
                Inputs:    inputInfos,
        }

        funcMap := template.FuncMap{
                "printAsciiDocTagsTmpl": printAsciiDocTagsTmpl,
        }

        tmpl, err := template.New("inputSectionTemplate").Funcs(funcMap).Parse(inputSectionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error parsing input section template: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(os.Stdout, data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error executing input section template: %v\n", err)
        }</span>
}

func getInputFieldsTableString(t *ast.Definition, definitionsMap map[string]*ast.Definition) (string, error) <span class="cov0" title="0">{
        if len(t.Fields) == 0 </span><span class="cov0" title="0">{
                return "", nil // No fields
        }</span>

        <span class="cov0" title="0">var builder strings.Builder

        // Use a local template instance for fields
        fieldTmpl, err := template.New("field").Funcs(template.FuncMap{
                "processDescription": processDescription,
        }).Parse(fieldTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse field template for input %s: %w", t.Name, err)
        }</span>

        // Add tags and headers specific to inputs
        // Note: Replicating tags from printObjectFields logic for Inputs
        <span class="cov0" title="0">builder.WriteString(fmt.Sprintf(ADOC_INPUT_DEF_START_TAG, t.Name))
        builder.WriteString(fmt.Sprintf("[[input_%s]]\n", strings.ToLower(t.Name)))
        builder.WriteString(fmt.Sprintf(".input: %s\n", t.Name))

        // Use TABLE_OPTIONS_4 for inputs as per printObjectFields
        builder.WriteString(TABLE_OPTIONS_3 + "\n")
        builder.WriteString(TABLE_SE + "\n")
        //builder.WriteString("| Type | Field | Description | Directives\n") // Header for Input Objects
        builder.WriteString("| Type | Field | Description\n") // Header for Input Objects

        for _, f := range t.Fields </span><span class="cov0" title="0">{
                typeName := processTypeName(f.Type.String(), definitionsMap)
                directives := getDirectivesStringTpl(f.Directives) // Using Tpl version for directives

                // Process description and extract changelog for input fields too
                processedDesc, changelog := processDescriptionWithChangelog(f.Description)

                data := FieldData{
                        Type:            typeName,
                        Name:            f.Name,
                        Description:     processedDesc, // Use processed description
                        RequiredOrArray: strings.Contains(typeName, "!") || strings.Contains(typeName, "["),
                        Required:        isRequiredTypeTpl(typeName),
                        IsArray:         strings.Contains(typeName, "["),
                        Directives:      directives, // Pass processed directives
                        Changelog:       changelog,
                }

                // Execute the field template into the builder
                err := fieldTmpl.Execute(&amp;builder, data)
                if err != nil </span><span class="cov0" title="0">{
                        // Attempt to continue, maybe log error?
                        builder.WriteString(fmt.Sprintf("| ERROR executing template for field %s | | |\n", f.Name))
                        // return "", fmt.Errorf("failed to execute field template for input field %s: %w", f.Name, err)
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString("\n") // Ensure newline after each row if template executed successfully
                }</span>
        }

        <span class="cov0" title="0">builder.WriteString(TABLE_SE + "\n")
        builder.WriteString(fmt.Sprintf(ADOC_INPUT_DEF_END_TAG, t.Name))

        return builder.String(), nil</span>
}

/**
 * Print the query details
 */
func processQueryOld(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        fmt.Println("== Query")
        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                if t.Kind == ast.Object &amp;&amp; t.Name == "Query" </span><span class="cov0" title="0">{
                        fmt.Printf(CROSS_REF, t.Name) // Add anchor
                        //fmt.Printf("=== %s\n\n", t.Name)

                        if t.Description != "" </span><span class="cov0" title="0">{
                                printAsciiDocTags(t.Description)
                        }</span>

                        <span class="cov0" title="0">printQuery(t, definitionsMap)

                        fmt.Println()</span>
                }
        }
}

/**
 * Print the query details
 */
func printQueries(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        fmt.Println("== Query")
        fmt.Println()

        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                if t.Kind == ast.Object &amp;&amp; t.Name == "Query" </span><span class="cov0" title="0">{
                        //fmt.Printf(CROSS_REF, camelToSnake(t.Name)) // Add anchor
                        fmt.Println()

                        if t.Description != "" </span><span class="cov0" title="0">{
                                printAsciiDocTags(t.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()

                        printQueryDetails(t, definitionsMap)

                        fmt.Println()</span>
                }
        }
}

func printObjectFieldsTpl(data FieldData) <span class="cov0" title="0">{

        //func printObjectFieldsTpl(t *ast.Definition, definitionsMap map[string]*ast.Definition) {
        //tmpl := template.Must(template.New("field").Parse(fieldTemplate))

        tmpl := template.Must(template.New("field").Funcs(template.FuncMap{
                "processDescription": processDescription,
        }).Parse(fieldTemplate))

        //        for _, f := range t.Fields {
        //                typeName := processTypeName(f.Type.String(), definitionsMap)
        //                data := FieldData{
        //                        Type:            typeName,
        //                        Name:            f.Name,
        //                        Description:     f.Description,
        //                        RequiredOrArray: strings.Contains(typeName, "!") || strings.Contains(typeName, "["),
        //                        Required:        isRequiredTypeTpl(typeName),
        //                        IsArray:         strings.Contains(typeName, "["),
        //                        Directives:      getDirectivesStringTpl(f.Directives),
        //                }
        tmpl.Execute(os.Stdout, data)
        // }
}</span>

func getRequiredString(typeName string) string <span class="cov0" title="0">{
        switch </span>{
        case strings.Contains(typeName, "]!"):<span class="cov0" title="0">
                return "True (more than one)"</span>
        case strings.Contains(typeName, "!]"):<span class="cov0" title="0">
                return "True (at least one, if provided)"</span>
        case strings.Contains(typeName, "!"):<span class="cov0" title="0">
                return "True"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

/**
 * Print the objects to a table.
 */
func printObjectFields(t *ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        if len(t.Fields) &gt; 0 </span><span class="cov0" title="0">{
                if t.Name != "Query" </span><span class="cov0" title="0">{
                        if t.IsInputType() </span><span class="cov0" title="0">{
                                fmt.Printf(ADOC_INPUT_DEF_START_TAG, t.Name)          // Add type tag to table
                                fmt.Printf("[[input_%s]]\n", strings.ToLower(t.Name)) // Add input tag to table
                                fmt.Printf(".input: %s\n", t.Name)                    // Add input header to table
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf(ADOC_TYPE_DEF_START_TAG, t.Name)          // Add type tag to table
                                fmt.Printf("[[type-%s]]\n", strings.ToLower(t.Name)) // Add type tag to table
                                fmt.Printf(".type: %s\n", t.Name)                    // Add type header to table
                        }</span>
                }
                <span class="cov0" title="0">if t.Name == "Query" </span><span class="cov0" title="0">{

                        fmt.Println(TABLE_OPTIONS_3)
                        fmt.Println(TABLE_SE)
                        fmt.Println("| Return | Function | Description")
                }</span> else<span class="cov0" title="0"> if t.Name == "InputObject" </span><span class="cov0" title="0">{
                        fmt.Println(TABLE_OPTIONS_4)
                        fmt.Println(TABLE_SE)
                        //fmt.Println("| Type | Field | Description")
                        fmt.Println("| Type | Field | Description | Directives")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(TABLE_OPTIONS_3)
                        fmt.Println(TABLE_SE)
                        fmt.Println("| Type | Field | Description ")
                }</span>

                <span class="cov0" title="0">for _, f := range t.Fields </span><span class="cov0" title="0">{
                        typeName := f.Type.String()
                        typeName = processTypeName(typeName, definitionsMap)
                        directives := getDirectivesString(f.Directives)

                        if t.Name == "Query" </span><span class="cov0" title="0">{
                                // if it is the query type
                                fmt.Printf("| %s | %s | %s\n", typeName, f.Name, processDescription(f.Description))
                        }</span> else<span class="cov0" title="0"> if t.Name == "InputObject" </span><span class="cov0" title="0">{
                                fmt.Printf("| %s | %s | %s | %s\n", typeName, f.Name, f.Description, prependStringIfNotEmpty(directives, "\n"))
                        }</span> else<span class="cov0" title="0"> {

                                fmt.Println()

                                data := FieldData{
                                        Type:            typeName,
                                        Name:            f.Name,
                                        Description:     f.Description,
                                        RequiredOrArray: strings.Contains(typeName, "!") || strings.Contains(typeName, "["),
                                        Required:        isRequiredTypeTpl(typeName),
                                        IsArray:         strings.Contains(typeName, "["),
                                        Directives:      getDirectivesStringTpl(f.Directives),
                                }
                                printObjectFieldsTpl(data)

                                // if it is not the query type
                                //fmt.Printf("| %s | %s | %s%s%s%s%s\n", typeName, f.Name, addStringIfNotEmpty(processDescription(f.Description), "\n"),
                                //        prependStringIfNotEmpty(isRequiredOrArrayType(typeName), "\n"),
                                //        prependStringIfNotEmpty(isRequiredType(typeName), "\n"),
                                //        isArrayType(typeName),
                                //        prependStringIfNotEmpty(directives, "\n"))
                        }</span>
                }

                <span class="cov0" title="0">fmt.Println(TABLE_SE)

                if t.IsInputType() </span><span class="cov0" title="0">{
                        fmt.Printf(ADOC_INPUT_DEF_END_TAG, t.Name) // Add input tag to table
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf(ADOC_TYPE_DEF_END_TAG, t.Name) // Add type tag to table
                }</span>
        }
}

/*

func processDescription(description string) string {
        // Replace * and - with newline followed by the character
        processed := strings.ReplaceAll(description, "*", "\n*")
        processed = strings.ReplaceAll(processed, "-", "\n-")
        // Remove any double newlines that might have been created
        //processed = strings.ReplaceAll(processed, "\n\n", "\n")
        // Remove newline at start if present
        return strings.TrimPrefix(processed, "\n")
}
*/

func addStringIfNotEmpty(s string, add string) string <span class="cov0" title="0">{
        if s != "" </span><span class="cov0" title="0">{
                return s + add
        }</span>
        <span class="cov0" title="0">return s</span>
}

func prependStringIfNotEmpty(s string, add string) string <span class="cov0" title="0">{
        if s != "" </span><span class="cov0" title="0">{
                return add + s
        }</span>
        <span class="cov0" title="0">return s</span>
}

func addPlusIfNotEmpty(s string) string <span class="cov0" title="0">{
        if s != "" </span><span class="cov0" title="0">{
                return s + " +"
        }</span>
        <span class="cov0" title="0">return s</span>
}

func addPlusIfBothNotEmpty(s1 string, s2 string) string <span class="cov0" title="0">{
        if s1 != "" &amp;&amp; s2 != "" </span><span class="cov0" title="0">{
                return s1 + ""
        }</span>
        <span class="cov0" title="0">return s1</span>
}

func addStringIfBothNotEmpty(s1 string, s2 string, add string) string <span class="cov0" title="0">{
        if s1 != "" &amp;&amp; s2 != "" </span><span class="cov0" title="0">{
                return s1 + add
        }</span>
        <span class="cov0" title="0">return s1</span>
}

/**
 * Print enum values in a table
 */
func printEnumValues(t *ast.Definition) <span class="cov0" title="0">{
        if len(t.EnumValues) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf(ADOC_ENUM_START_TAG, t.Name)
                fmt.Printf("[[enum_%s]]\n", camelToSnake(t.Name))
                fmt.Printf(".enum_%s\n", camelToSnake(t.Name))
                fmt.Println(TABLE_OPTIONS_2)
                fmt.Println(TABLE_SE)
                fmt.Println("| Value | Description")
                for _, v := range t.EnumValues </span><span class="cov0" title="0">{
                        fmt.Printf("| %s | %s\n", v.Name, v.Description)
                }</span>
                <span class="cov0" title="0">fmt.Println(TABLE_SE)
                fmt.Printf(ADOC_ENUM_END_TAG, t.Name)</span>
        }
}

/**
 * print asciidoc tags.
 */
/*func printAsciiDocTags(description string) {
        lines := strings.Split(description, "\n")
        for _, line := range lines {
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "# tag::") || strings.HasPrefix(trimmed, "# end::") {
                        fmt.Println("//" + trimmed[1:]) // remove the '#' as AsciiDoc comments start with '//' not '#'
                } else if !strings.HasPrefix(trimmed, "# ") {
                        // If it is not a comment, then print the line.
                        fmt.Println(trimmed)
                }
        }
}
*/
func printAsciiDocTags(description string) <span class="cov0" title="0">{
        re := regexp.MustCompile(`^#\s*(tag::|end::)(.*)`)
        lines := strings.Split(description, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if matches := re.FindStringSubmatch(line); matches != nil </span><span class="cov0" title="0">{
                        fmt.Println("//" + matches[1] + matches[2])
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(line)
                }</span>
        }
}

func printAsciiDocTagsTmpl(description string) string <span class="cov0" title="0">{
        re := regexp.MustCompile(`^#\s*(tag::|end::)(.*)`)
        lines := strings.Split(description, "\n")
        var result strings.Builder
        for _, line := range lines </span><span class="cov0" title="0">{
                if matches := re.FindStringSubmatch(line); matches != nil </span><span class="cov0" title="0">{
                        result.WriteString("//" + matches[1] + matches[2] + "\n")
                }</span> else<span class="cov0" title="0"> {
                        result.WriteString(line + "\n")
                }</span>
        }
        <span class="cov0" title="0">return result.String()</span>
}

/**
 * Print query as a table
 */
func printQuery(t *ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        if len(t.Fields) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println(TABLE_OPTIONS_4)
                fmt.Println(TABLE_SE)
                if t.Name == "Query" </span><span class="cov0" title="0">{
                        fmt.Println("| Return | Function | Description | params")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("| Type | Field | Description | params")
                }</span>

                <span class="cov0" title="0">for _, f := range t.Fields </span><span class="cov0" title="0">{
                        typeName := f.Type.String()
                        typeName = processTypeName(typeName, definitionsMap)
                        if t.Name == "Query" </span><span class="cov0" title="0">{
                                fmt.Println("| ", typeName)
                                fmt.Println("| ", f.Name)
                                fmt.Println("| ")
                                fmt.Println(f.Description)
                                fmt.Println("|", getArgsString(f.Arguments))
                                fmt.Println(" ")
                                fmt.Println(" ")
                        }</span> else<span class="cov0" title="0"> {
                                // Replace "{" with a space
                                stringWithoutBraces := strings.Replace(getArgsString(f.Arguments), "{", " ", -1)
                                // Replace "}" with a space
                                stringWithoutBraces = strings.Replace(stringWithoutBraces, "}", " ", -1)
                                fmt.Printf("| %s | %s | %s | %s \n", typeName, f.Name, f.Description, stringWithoutBraces)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("%s", TABLE_SE)</span>
        }
}

/**
 * Get the arguments for reconstructing the method signature
 */
func getArgsString(args ast.ArgumentDefinitionList) string <span class="cov0" title="0">{
        var argsStrings []string

        for _, arg := range args </span><span class="cov0" title="0">{
                argString := fmt.Sprintf("* `%s : %s", arg.Name, arg.Type.String())
                if arg.DefaultValue != nil </span><span class="cov0" title="0">{
                        argString += fmt.Sprintf(" (Default:%s)`", arg.DefaultValue.String())
                }</span> else<span class="cov0" title="0"> {
                        argString += "`"
                }</span>

                <span class="cov0" title="0">argsStrings = append(argsStrings, argString)</span>
        }
        <span class="cov0" title="0">return strings.Join(argsStrings, " + \n")</span>
}

/**
 * Get the type arguments.
 */
func getArgsMethodTypeString(args ast.ArgumentDefinitionList) (string, int) <span class="cov0" title="0">{
        var argsStrings []string
        var counter = 0
        for _, arg := range args </span><span class="cov0" title="0">{
                counter++
                argString := fmt.Sprintf("  %s: %s", arg.Name, arg.Type.String())
                if arg.DefaultValue != nil </span><span class="cov0" title="0">{
                        argString += fmt.Sprintf(" = %s", arg.DefaultValue.String())
                }</span>
                // if there is another argument, add a comma
                <span class="cov0" title="0">if arg != args[len(args)-1] </span><span class="cov0" title="0">{
                        argString += " ,"
                }</span>
                <span class="cov0" title="0">if includeAdocLineTags </span><span class="cov0" title="0">{
                        argString += fmt.Sprintf(" &lt;%d&gt; ", counter)
                }</span>

                <span class="cov0" title="0">argString += "\n"
                argsStrings = append(argsStrings, argString)</span>
        }

        <span class="cov0" title="0">return strings.Join(argsStrings, ""), counter</span>
}

/**
 * Print query details
 */
func printQueryDetails(t *ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        if len(t.Fields) &gt; 0 </span><span class="cov0" title="0">{
                for _, f := range t.Fields </span><span class="cov0" title="0">{
                        // Check if the query is internal
                        isInternal := strings.Contains(f.Description, "INTERNAL")

                        // Skip internal queries if excludeInternal is true
                        if *excludeInternal &amp;&amp; isInternal </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if f.Directives.ForName("deprecated") != nil </span>{<span class="cov0" title="0">
                                // Handle deprecated field
                                //continue // or mark it as deprecated in the documentation

                        }</span>

                        <span class="cov0" title="0">fmt.Printf(ADOC_QUERY_START_TAG, f.Name)
                        fmt.Println()
                        fmt.Printf("[[query_%s]]\n", strings.ToLower(f.Name))

                        // if f.Description contains INTERNAL then add teh word INTERNAL to the tag
                        if strings.Contains(f.Description, "INTERNAL") </span><span class="cov0" title="0">{
                                fmt.Printf(L3_TAG, f.Name+" [INTERNAL]")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf(L3_TAG, f.Name)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()
                        // Process description and extract changelog for queries
                        processedDesc, changelog := processDescriptionWithChangelog(f.Description)

                        if includeAdocLineTags </span><span class="cov0" title="0">{
                                fmt.Printf(ADOC_METHOD_DESC_START_TAG, f.Name)
                                fmt.Println(cleanDescription(processedDesc, "-"))
                                fmt.Printf(ADOC_METHOD_DESC_END_TAG, f.Name)
                                fmt.Println()
                        }</span>
                        <span class="cov0" title="0">fmt.Printf(ADOC_METHOD_SIG_START_TAG, f.Name)
                        fmt.Printf(".query: %s\n", f.Name)
                        fmt.Print(SOURCE_HEAD)
                        fmt.Println("----")
                        argsString, counter := getArgsMethodTypeString(f.Arguments)
                        if includeAdocLineTags </span><span class="cov0" title="0">{
                                counter++
                                fmt.Printf("%s(\n%s): %s &lt;%d&gt;\n", f.Name, argsString, f.Type.String(), counter)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("%s(\n%s): %s\n", f.Name, argsString, f.Type.String())
                        }</span>
                        <span class="cov0" title="0">fmt.Println("----")
                        fmt.Printf(ADOC_METHOD_SIG_END_TAG, f.Name)
                        fmt.Println()
                        fmt.Printf(ADOC_METHOD_ARGS_START_TAG, f.Name)
                        if includeAdocLineTags </span><span class="cov0" title="0">{
                                fmt.Println(convertDescriptionToRefNumbers(processedDesc, true))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(processedDesc)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf(ADOC_METHOD_ARGS_END_TAG, f.Name)
                        fmt.Println()

                        typeName := f.Type.String()

                        typeName = processTypeName(typeName, definitionsMap)
                        fmt.Printf("// tag::query-name-%s[]\n", f.Name)
                        fmt.Printf("*Query Name:* _%s_\n", f.Name)
                        fmt.Printf("// end::query-name-%s[]\n", f.Name)
                        fmt.Println()
                        fmt.Printf("// tag::query-return-%s[]\n", f.Name)
                        fmt.Printf("*Return:* %s\n", typeName)
                        fmt.Printf("// end::query-return-%s[]\n", f.Name)
                        fmt.Println()

                        if len(f.Arguments) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("// tag::arguments-%s[]\n", f.Name)
                                fmt.Printf(".Arguments\n")
                                // Replace "{" with a space
                                stringWithoutBraces := strings.Replace(getArgsString(f.Arguments), "{", " ", -1)
                                // Replace "}" with a space
                                stringWithoutBraces = strings.Replace(stringWithoutBraces, "}", " ", -1)
                                fmt.Println(stringWithoutBraces)
                                fmt.Printf("// end::arguments-%s[]\n", f.Name)
                                fmt.Println()
                        }</span>

                        // Add changelog section for queries
                        <span class="cov0" title="0">if changelog != "" </span><span class="cov0" title="0">{
                                fmt.Printf("// tag::query-changelog-%s[]\n", f.Name)
                                fmt.Print(changelog)
                                fmt.Printf("// end::query-changelog-%s[]\n", f.Name)
                                fmt.Println()
                        }</span>

                        <span class="cov0" title="0">fmt.Printf(ADOC_QUERY_END_TAG, f.Name)
                        fmt.Println()</span>
                }
        }
}

func isRequiredOrArrayType(typeName string) string <span class="cov0" title="0">{
        //if strings.Contains(typeName, "!") || strings.Contains(typeName, "[") || strings.Contains(typeName, "]") {
        //        return "\n\n.Notes\n"
        //}
        return ""
}</span>

func isRequiredType(typeName string) string <span class="cov0" title="0">{
        if strings.Contains(typeName, "]!") </span><span class="cov0" title="0">{
                return "\n.Required:\n* `True` (more than one) "
        }</span> else<span class="cov0" title="0"> {
                if strings.Contains(typeName, "!]") </span><span class="cov0" title="0">{
                        return "\n.Required:\n* `True` (at least one, if provided) "
                }</span> else<span class="cov0" title="0"> {
                        if strings.Contains(typeName, "!") </span><span class="cov0" title="0">{
                                return "\n.Required:\n* `True` "
                        }</span> else<span class="cov0" title="0"> {
                                return ""
                        }</span>
                }
        }
}

func isRequiredTypeTpl(typeName string) string <span class="cov0" title="0">{
        if strings.Contains(typeName, "]!") </span><span class="cov0" title="0">{
                return "`True` (more than one) "
        }</span> else<span class="cov0" title="0"> {
                if strings.Contains(typeName, "!]") </span><span class="cov0" title="0">{
                        return "`True` (at least one, if provided) "
                }</span> else<span class="cov0" title="0"> {
                        if strings.Contains(typeName, "!") </span><span class="cov0" title="0">{
                                return "`True` "
                        }</span> else<span class="cov0" title="0"> {
                                return ""
                        }</span>
                }
        }
}

func isArrayType(typeName string) string <span class="cov0" title="0">{
        if strings.Contains(typeName, "[") &amp;&amp; strings.Contains(typeName, "]") </span><span class="cov0" title="0">{
                return "\n.Array:\n* `True` "
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}
func isArrayTypeTpl(typeName string) string <span class="cov0" title="0">{
        if strings.Contains(typeName, "[") &amp;&amp; strings.Contains(typeName, "]") </span><span class="cov0" title="0">{
                return "* `True` "
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}

func hasDirectives(typeName string) string <span class="cov0" title="0">{
        if strings.Contains(typeName, "@") </span><span class="cov0" title="0">{
                // search between the @ symbol and the first space or new line

                // Find the index of the @ symbol
                //atIndex := strings.Index(typeName, "@")
                // Find the index of the first space after the @ symbol
                //spaceIndex := strings.Index(typeName[atIndex:], " ")
                // Find the index of the first new line after the @ symbol
                //newLineIndex := strings.Index(typeName[atIndex:], "\n")

                return "\n* `Directives: True` "
                //+ "+ \n* `Directivetype: `" + typeName[atIndex:atIndex+newLineIndex] +'`'

        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}

/**
 * Process the type name, adding the asciidoc links if needed.
 */
func processTypeName(typeName string, definitionsMap map[string]*ast.Definition) string <span class="cov5" title="8">{
        // Assuming typeName may be a list type like "[TypeName]"
        // Trim the square brackets if they exist to extract the actual type name
        trimmedTypeName := strings.Trim(typeName, "[]")

        if definitionsMap[trimmedTypeName] != nil &amp;&amp; definitionsMap[trimmedTypeName].Kind == ast.Object </span><span class="cov2" title="2">{
                // If it's a list type, add back the square brackets
                if strings.HasPrefix(typeName, "[") &amp;&amp; strings.HasSuffix(typeName, "]") </span><span class="cov1" title="1">{
                        typeName = fmt.Sprintf("[&lt;&lt;%s,`%s`&gt;&gt;]", trimmedTypeName, trimmedTypeName)
                }</span> else<span class="cov1" title="1"> {
                        typeName = fmt.Sprintf("&lt;&lt;%s,`%s`&gt;&gt;", trimmedTypeName, trimmedTypeName)
                }</span>
        } else<span class="cov4" title="6"> {
                // If it's a type, and it is greater than 0, but is is not a special type, then just wrap it.
                if len(typeName) &gt; 0 </span><span class="cov4" title="6">{
                        typeName = fmt.Sprintf("`%s`", typeName)
                }</span>
        }

        <span class="cov5" title="8">return typeName</span>
}

func camelToSnake(s string) string <span class="cov5" title="9">{
        var result strings.Builder
        for i, v := range s </span><span class="cov10" title="65">{
                if unicode.IsUpper(v) </span><span class="cov7" title="19">{
                        if i != 0 </span><span class="cov6" title="12">{
                                result.WriteByte('_')
                        }</span>
                        <span class="cov7" title="19">result.WriteRune(unicode.ToLower(v))</span>
                } else<span class="cov9" title="46"> {
                        result.WriteRune(v)
                }</span>
        }
        <span class="cov5" title="9">return result.String()</span>
}

/*
A function to convert the text

- &lt;optional-filter&gt; `studentCode`: String - Single or multiple student ids or student codes.
- &lt;optional-filter&gt; `subjectCode`: String - Single or multiple subject codes.

to the text
&lt;1&gt; &lt;optional-filter&gt; `studentCode`: String - Single or multiple student ids or student codes.
&lt;2&gt; &lt;optional-filter&gt; `subjectCode`: String - Single or multiple subject codes.
*/
/*func convertDescriptionToRefNumbers(text string, skipNonDash bool) string {
        lines := strings.Split(text, "\n")
        var result strings.Builder

        refNum := 1
        for i, line := range lines {
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "-") {
                        // If the line starts with a hyphen, then add the counter and the line
                        // not including the - in the line
                        result.WriteString(fmt.Sprintf("&lt;%d&gt; %s\n", refNum, line[1:]))
                        refNum++
                } else {
                        if !skipNonDash {
                                // If the line does not start with a hyphen, then add the line
                                result.WriteString(line + "\n")
                        }
                }
                i++
        }
        return result.String()
}
*/
func convertDescriptionToRefNumbers(text string, skipNonDash bool) string <span class="cov3" title="3">{
        lines := strings.Split(text, "\n")
        var result strings.Builder
        refNum := 1
        for _, line := range lines </span><span class="cov6" title="11">{
                trimmed := strings.TrimSpace(line)
                // ignore if the string starts with --
                if strings.HasPrefix(trimmed, "-") &amp;&amp; !strings.HasPrefix(trimmed, "--") </span><span class="cov4" title="5">{
                        lineContent := strings.TrimSpace(trimmed[1:])
                        result.WriteString(fmt.Sprintf("&lt;%d&gt; %s\n", refNum, lineContent))
                        refNum++
                }</span> else<span class="cov4" title="6"> if !skipNonDash </span><span class="cov3" title="4">{
                        result.WriteString(line + "\n")
                }</span>
        }
        <span class="cov3" title="3">return result.String()</span>
}

/*
A function to convert the text

# My fancy description

- &lt;optional-filter&gt; `studentCode`: String - Single or multiple student ids or student codes.
- &lt;optional-filter&gt; `subjectCode`: String - Single or multiple subject codes.

to the text

My fancy description
*/
func cleanDescription(text string, skipCharacter string) string <span class="cov3" title="3">{
        lines := strings.Split(text, "\n")
        var result strings.Builder
        for _, line := range lines </span><span class="cov6" title="12">{
                trimmed := strings.TrimSpace(line)
                // Don't skip AsciiDoc code block delimiters (----) even if skipCharacter is "-"
                if !strings.HasPrefix(trimmed, skipCharacter) || trimmed == "----" </span><span class="cov5" title="8">{
                        result.WriteString(line + "\n")
                }</span>
        }
        <span class="cov3" title="3">return result.String()</span>
}

func printAsciiDocTag(startTag, content, endTag string) <span class="cov0" title="0">{
        fmt.Printf(startTag)
        fmt.Println(content)
        fmt.Printf(endTag)
}</span>

func getTypeName(t *ast.Type) string <span class="cov0" title="0">{
        if t.Elem != nil </span><span class="cov0" title="0">{
                return "[" + getTypeName(t.Elem) + "]"
        }</span>
        <span class="cov0" title="0">return t.NamedType</span>
}

func getDirectivesStringTpl(directives ast.DirectiveList) string <span class="cov0" title="0">{
        if len(directives) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var directiveStrings []string
        for _, dir := range directives </span><span class="cov0" title="0">{
                dirStr := fmt.Sprintf("@%s", dir.Name)

                if len(dir.Arguments) &gt; 0 </span><span class="cov0" title="0">{
                        args := make([]string, 0, len(dir.Arguments))
                        for _, arg := range dir.Arguments </span><span class="cov0" title="0">{
                                args = append(args, fmt.Sprintf("%s: %s", arg.Name, arg.Value.String()))
                        }</span>
                        <span class="cov0" title="0">dirStr += fmt.Sprintf("(%s)", strings.Join(args, ", "))</span>
                }

                <span class="cov0" title="0">directiveStrings = append(directiveStrings, ("`" + dirStr + "`"))</span>
        }

        <span class="cov0" title="0">return "\n* " + strings.Join(directiveStrings, "\n")</span>
}

func getDirectivesString(directives ast.DirectiveList) string <span class="cov0" title="0">{
        if len(directives) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var directiveStrings []string
        for _, dir := range directives </span><span class="cov0" title="0">{
                dirStr := fmt.Sprintf("@%s", dir.Name)

                if len(dir.Arguments) &gt; 0 </span><span class="cov0" title="0">{
                        args := make([]string, 0, len(dir.Arguments))
                        for _, arg := range dir.Arguments </span><span class="cov0" title="0">{
                                args = append(args, fmt.Sprintf("%s: %s", arg.Name, arg.Value.String()))
                        }</span>
                        <span class="cov0" title="0">dirStr += fmt.Sprintf("(%s)", strings.Join(args, ", "))</span>
                }

                <span class="cov0" title="0">directiveStrings = append(directiveStrings, ("`" + dirStr + "`"))</span>
        }

        <span class="cov0" title="0">return "\n.Directives:\n* " + strings.Join(directiveStrings, "\n")</span>
}

func printDirectives(doc *ast.SchemaDocument) <span class="cov0" title="0">{
        if len(doc.Directives) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Print(DIRECTIVES_TAG)
        fmt.Println()
        fmt.Println(TABLE_OPTIONS_3)
        fmt.Println(TABLE_SE)
        fmt.Println("| Directive | Arguments | Description")

        for _, dir := range doc.Directives </span><span class="cov0" title="0">{
                args := make([]string, 0, len(dir.Arguments))
                for _, arg := range dir.Arguments </span><span class="cov0" title="0">{
                        args = append(args, fmt.Sprintf("%s: %s", arg.Name, arg.Type.String()))
                }</span>

                <span class="cov0" title="0">fmt.Printf("| @%s | %s | %s\n",
                        dir.Name,
                        strings.Join(args, ", "),
                        dir.Description)</span>
        }

        <span class="cov0" title="0">fmt.Println(TABLE_SE)
        fmt.Println()</span>
}

// Template version of printing scalar information.
func printScalarsTmpl(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        var scalars []Scalar
        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                if t.Kind == ast.Scalar </span><span class="cov0" title="0">{
                        scalars = append(scalars, Scalar{
                                Name:        t.Name,
                                Description: t.Description,
                                CrossRef:    fmt.Sprintf(CROSS_REF, camelToSnake(t.Name)),
                                L3Tag:       fmt.Sprintf(L3_TAG, t.Name),
                        })
                }</span>
        }

        <span class="cov0" title="0">data := ScalarData{
                ScalarTag:    SCALAR_TAG,
                FoundScalars: len(scalars) &gt; 0,
                Scalars:      scalars,
        }

        tmpl, err := template.New("scalarTemplate").Funcs(template.FuncMap{
                "printAsciiDocTagsTmpl": printAsciiDocTagsTmpl,
        }).Parse(scalarTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing template:", err)
                return
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(os.Stdout, data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error executing template:", err)
        }</span>
}

func printSubscriptionsTmpl(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        var subscriptions []Subscription
        foundSubscriptions := false

        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                if t.Kind == ast.Object &amp;&amp; t.Name == "Subscription" </span><span class="cov0" title="0">{
                        foundSubscriptions = true

                        var description string
                        if t.Description != "" </span><span class="cov0" title="0">{
                                description = printAsciiDocTagsTmpl(t.Description)
                        }</span>

                        <span class="cov0" title="0">details := getSubscriptionDetailsTmpl(t, definitionsMap)

                        subscriptions = append(subscriptions, Subscription{
                                Description: description,
                                Details:     details,
                        })</span>
                }
        }

        <span class="cov0" title="0">data := SubscriptionData{
                FoundSubscriptions: foundSubscriptions,
                Subscriptions:      subscriptions,
        }

        tmpl, err := template.New("subscriptionTemplate").Funcs(template.FuncMap{
                "printAsciiDocTagsTmpl": printAsciiDocTagsTmpl,
        }).Parse(subscriptionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing template:", err)
                return
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(os.Stdout, data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error executing template:", err)
        }</span>
}

func getSubscriptionDetailsTmpl(t *ast.Definition, definitionsMap map[string]*ast.Definition) string <span class="cov0" title="0">{
        var details strings.Builder

        if len(t.Fields) &gt; 0 </span><span class="cov0" title="0">{
                for _, f := range t.Fields </span><span class="cov0" title="0">{
                        // Check if the subscription is internal
                        isInternal := strings.Contains(f.Description, "INTERNAL")

                        // Skip internal subscriptions if excludeInternal is true
                        if *excludeInternal &amp;&amp; isInternal </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if f.Directives.ForName("deprecated") != nil </span><span class="cov0" title="0">{
                                details.WriteString(fmt.Sprintf("// tag::deprecated-%s[]\n", f.Name))
                                details.WriteString(fmt.Sprintf(".Deprecated: %s\n", f.Name))
                                details.WriteString(fmt.Sprintf("// end::deprecated-%s[]\n", f.Name))
                                details.WriteString("\n")
                        }</span>

                        <span class="cov0" title="0">details.WriteString(fmt.Sprintf("=== %s\n", f.Name))
                        details.WriteString("\n")

                        if f.Description != "" </span><span class="cov0" title="0">{
                                details.WriteString(printAsciiDocTagsTmpl(f.Description))
                                details.WriteString("\n")
                        }</span>

                        <span class="cov0" title="0">details.WriteString(fmt.Sprintf(".subscription: %s\n", f.Name))
                        details.WriteString(SOURCE_HEAD)
                        details.WriteString("----\n")
                        argsString, counter := getArgsMethodTypeString(f.Arguments)
                        if includeAdocLineTags </span><span class="cov0" title="0">{
                                counter++
                                details.WriteString(fmt.Sprintf("%s(\n%s): %s &lt;%d&gt;\n", f.Name, argsString, f.Type.String(), counter))
                        }</span> else<span class="cov0" title="0"> {
                                details.WriteString(fmt.Sprintf("%s(\n%s): %s\n", f.Name, argsString, f.Type.String()))
                        }</span>
                        <span class="cov0" title="0">details.WriteString("----\n")
                        details.WriteString("\n")

                        if len(f.Directives) &gt; 0 </span><span class="cov0" title="0">{
                                details.WriteString(fmt.Sprintf("// tag::subscription-directives-%s[]\n", f.Name))
                                details.WriteString(".Directives\n")
                                details.WriteString(getDirectivesString(f.Directives) + "\n")
                                details.WriteString(fmt.Sprintf("// end::subscription-directives-%s[]\n", f.Name))
                                details.WriteString("\n")
                        }</span>

                        <span class="cov0" title="0">details.WriteString(fmt.Sprintf(ADOC_QUERY_END_TAG, f.Name))
                        details.WriteString("\n")</span>
                }
        }

        <span class="cov0" title="0">return details.String()</span>
}

func printMutationsTmpl(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) <span class="cov0" title="0">{
        var mutations []Mutation
        var mutationObjectDescription string
        foundMutations := false
        mutationDefinition := (*ast.Definition)(nil) // Find the Mutation object definition

        for _, t := range sortedDefs </span><span class="cov0" title="0">{
                if t.Kind == ast.Object &amp;&amp; t.Name == "Mutation" </span><span class="cov0" title="0">{
                        mutationDefinition = t
                        if t.Description != "" </span><span class="cov0" title="0">{
                                // Store the description for the template
                                mutationObjectDescription = t.Description
                        }</span>
                        <span class="cov0" title="0">break</span> // Found the Mutation object
                }
        }

        <span class="cov0" title="0">if mutationDefinition != nil </span><span class="cov0" title="0">{
                for _, f := range mutationDefinition.Fields </span><span class="cov0" title="0">{
                        // Check if the mutation is internal
                        isInternal := strings.Contains(f.Description, "INTERNAL")

                        // Skip internal mutations if excludeInternal is true
                        if *excludeInternal &amp;&amp; isInternal </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Skip deprecated mutations
                        <span class="cov0" title="0">if f.Directives.ForName("deprecated") != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">foundMutations = true // We found at least one non-skipped mutation

                        typeName := processTypeName(f.Type.String(), definitionsMap)
                        arguments := ""
                        if len(f.Arguments) &gt; 0 </span><span class="cov0" title="0">{
                                arguments = getArgsString(f.Arguments)
                        }</span>
                        <span class="cov0" title="0">directives := ""
                        if len(f.Directives) &gt; 0 </span><span class="cov0" title="0">{
                                directives = getDirectivesString(f.Directives)
                        }</span>
                        // Process description and extract changelog
                        <span class="cov0" title="0">processedDesc, changelog := processDescriptionWithChangelog(f.Description)
                        cleanedDescription := cleanDescription(processedDesc, "-")

                        // --- Construct Method Signature Block ---
                        var signatureBlock strings.Builder
                        signatureBlock.WriteString(fmt.Sprintf("// tag::method-signature-%s[]\n", f.Name)) // Re-add tag here for consistency if needed, or rely on outer one
                        signatureBlock.WriteString(fmt.Sprintf(".mutation: %s\n", f.Name))
                        signatureBlock.WriteString(SOURCE_HEAD)
                        signatureBlock.WriteString("----\n")
                        argsString, counter := getArgsMethodTypeString(f.Arguments)
                        // Always use line tags for consistency with printMutationDetails
                        counter++
                        signatureBlock.WriteString(fmt.Sprintf("%s(\n%s): %s &lt;%d&gt;\n", f.Name, argsString, f.Type.String(), counter))
                        signatureBlock.WriteString("----\n")
                        signatureBlock.WriteString(fmt.Sprintf("// end::method-signature-%s[]\n", f.Name)) // Re-add tag here for consistency
                        // --- End Method Signature Block ---

                        mutations = append(mutations, Mutation{
                                Name:                 f.Name,
                                Description:          processedDesc,      // Pass processed description for convertDescriptionToRefNumbers
                                CleanedDescription:   cleanedDescription, // Pass cleaned description
                                TypeName:             typeName,
                                Arguments:            arguments,
                                Directives:           directives,
                                HasArguments:         len(f.Arguments) &gt; 0,
                                HasDirectives:        len(f.Directives) &gt; 0,
                                AnchorName:           "mutation_" + strings.ToLower(f.Name), // Generate anchor name
                                IsInternal:           isInternal,                            // Pass internal flag
                                MethodSignatureBlock: signatureBlock.String(),               // Pass signature block
                                Changelog:            changelog,                             // Pass changelog
                        })</span>
                }
        }

        <span class="cov0" title="0">data := MutationData{
                Mutations:                 mutations,
                MutationObjectDescription: mutationObjectDescription, // Pass object description
                FoundMutations:            foundMutations,            // Pass flag
                MutationTag:               "== Mutations",            // Pass header tag
        }

        // Add printAsciiDocTagsTmpl to FuncMap
        funcMap := template.FuncMap{
                "convertDescriptionToRefNumbers": convertDescriptionToRefNumbers,
                "printAsciiDocTagsTmpl":          printAsciiDocTagsTmpl,
        }

        tmpl, err := template.New("mutationTemplate").Funcs(funcMap).Parse(mutationTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing mutation template:", err)
                return
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(os.Stdout, data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error executing mutation template:", err)
        }</span>
}

// Add this helper function
func getTypeFieldsTableString(t *ast.Definition, definitionsMap map[string]*ast.Definition) (string, error) <span class="cov0" title="0">{
        var builder strings.Builder

        if len(t.Fields) == 0 </span><span class="cov0" title="0">{
                return "", nil // No fields, return empty string
        }</span>

        // Use a local template instance for fields
        <span class="cov0" title="0">fieldTmpl, err := template.New("field").Funcs(template.FuncMap{
                "processDescription": processDescription,
        }).Parse(fieldTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse field template: %w", err)
        }</span>

        // Add tags and headers specific to types (not inputs)
        <span class="cov0" title="0">builder.WriteString(fmt.Sprintf(ADOC_TYPE_DEF_START_TAG, t.Name))
        builder.WriteString(fmt.Sprintf("[[type_def_%s]]\n", strings.ToLower(t.Name)))
        builder.WriteString(fmt.Sprintf(".type: %s\n", t.Name))

        builder.WriteString(TABLE_OPTIONS_3 + "\n")
        builder.WriteString(TABLE_SE + "\n")
        builder.WriteString("| Type | Field | Description \n") // Header for types

        for _, f := range t.Fields </span><span class="cov0" title="0">{
                typeName := processTypeName(f.Type.String(), definitionsMap)

                // Process description and extract changelog
                processedDesc, changelog := processDescriptionWithChangelog(f.Description)

                data := FieldData{
                        Type:            typeName,
                        Name:            f.Name,
                        Description:     processedDesc,
                        RequiredOrArray: strings.Contains(typeName, "!") || strings.Contains(typeName, "["),
                        Required:        isRequiredTypeTpl(typeName), // Use Tpl version
                        IsArray:         strings.Contains(typeName, "["),
                        Directives:      getDirectivesStringTpl(f.Directives), // Use Tpl version
                        Changelog:       changelog,
                }

                // Execute the field template into the builder
                err := fieldTmpl.Execute(&amp;builder, data)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to execute field template for field %s: %w", f.Name, err)
                }</span>
                <span class="cov0" title="0">builder.WriteString("\n")</span> // Ensure newline after each row
        }

        <span class="cov0" title="0">builder.WriteString(TABLE_SE + "\n")
        builder.WriteString(fmt.Sprintf(ADOC_TYPE_DEF_END_TAG, t.Name))

        return builder.String(), nil</span>
}

// Add this new function
func printDirectivesTmpl(doc *ast.SchemaDocument) <span class="cov0" title="0">{
        var directiveInfos []DirectiveInfo
        foundDirectives := len(doc.Directives) &gt; 0

        if foundDirectives </span><span class="cov0" title="0">{
                for _, dir := range doc.Directives </span><span class="cov0" title="0">{
                        // Format arguments
                        args := make([]string, 0, len(dir.Arguments))
                        for _, arg := range dir.Arguments </span><span class="cov0" title="0">{
                                args = append(args, fmt.Sprintf("%s: %s", arg.Name, arg.Type.String()))
                        }</span>
                        <span class="cov0" title="0">argumentsString := strings.Join(args, ", ") // Create the formatted string

                        directiveInfos = append(directiveInfos, DirectiveInfo{
                                Name:        dir.Name,
                                Arguments:   argumentsString,
                                Description: processDescription(dir.Description),
                        })</span>
                }
        }

        // Define table options string in Go code
        <span class="cov0" title="0">tableOptions := `[width="90%", cols="2a,2a,6a" options="header" orientation="landscape" grid="none" stripes="even" , frame="topbot"]`

        data := DirectiveSectionData{
                DirectivesTag:   DIRECTIVES_TAG, // Use existing constant
                FoundDirectives: foundDirectives,
                Directives:      directiveInfos,
                TableOptions:    tableOptions, // Pass the string
        }

        // No custom functions needed for this simple template
        tmpl, err := template.New("directiveSectionTemplate").Parse(directiveSectionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error parsing directive section template: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(os.Stdout, data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error executing directive section template: %v\n", err)
        }</span>
}

// Add this helper function
func getEnumValuesTableString(t *ast.Definition) string <span class="cov0" title="0">{
        if len(t.EnumValues) == 0 </span><span class="cov0" title="0">{
                return "" // No values, return empty string
        }</span>

        <span class="cov0" title="0">var builder strings.Builder

        builder.WriteString(fmt.Sprintf(ADOC_ENUM_START_TAG, t.Name))
        builder.WriteString(fmt.Sprintf("[[enum_%s]]\n", camelToSnake(t.Name)))
        builder.WriteString(fmt.Sprintf(".enum_%s\n", camelToSnake(t.Name)))
        builder.WriteString(TABLE_OPTIONS_2 + "\n")
        builder.WriteString(TABLE_SE + "\n")
        builder.WriteString("| Value | Description\n")
        for _, v := range t.EnumValues </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf("| %s | %s\n", v.Name, v.Description))
        }</span>
        <span class="cov0" title="0">builder.WriteString(TABLE_SE + "\n")
        builder.WriteString(fmt.Sprintf(ADOC_ENUM_END_TAG, t.Name))

        return builder.String()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
