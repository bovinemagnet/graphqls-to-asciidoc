package generator

import (
	"bytes"
	"fmt"
	"strings"
	"testing"

	"github.com/vektah/gqlparser/v2/ast"

	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/config"
)

func TestNew(t *testing.T) {
	cfg := &config.Config{SchemaFile: "test.graphql"}
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer

	gen := New(cfg, schema, &buf)

	if gen == nil {
		t.Fatal("New() returned nil")
	}
	if gen.config != cfg {
		t.Error("Config not set correctly")
	}
	if gen.schema != schema {
		t.Error("Schema not set correctly")
	}
	if gen.writer != &buf {
		t.Error("Writer not set correctly")
	}
}

func TestGeneratorPrintHeader(t *testing.T) {
	cfg := &config.Config{SchemaFile: "test/schema.graphql"}
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.printHeader()
	output := buf.String()

	expectedContains := []string{
		"= GraphQL Documentation",
		":toc: left",
		":revdate:",
		":commandline:",
		":sourceFile: test/schema.graphql",
		":reproducible:",
		":page-partial:",
		":sect-anchors:",
		":table-caption!:",
		":table-stripes: even",
		":pdf-page-size: A4",
		":tags: api, GraphQL, nodes, types, query",
		"[IMPORTANT]",
		"This is automatically generated",
		"Do not edit this file directly",
	}

	for _, expected := range expectedContains {
		if !strings.Contains(output, expected) {
			t.Errorf("Header should contain %q, but doesn't. Output:\n%s", expected, output)
		}
	}
}

func TestGenerateWithEmptySchema(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "empty.graphql"
	schema := &ast.Schema{
		Types:      make(map[string]*ast.Definition),
		Directives: make(map[string]*ast.DirectiveDefinition),
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	err := gen.Generate()
	if err != nil {
		t.Errorf("Generate() returned error: %v", err)
	}
	output := buf.String()

	// Should at least contain header
	if !strings.Contains(output, "= GraphQL Documentation") {
		t.Error("Output should contain header")
	}

	// Should contain placeholder messages for empty sections
	expectedPlaceholders := []string{}

	for _, placeholder := range expectedPlaceholders {
		if !strings.Contains(output, placeholder) {
			t.Errorf("Output should contain placeholder %q", placeholder)
		}
	}

	// Inputs section should show "No input types exist" when no input types are present
	if !strings.Contains(output, "No input types exist in this schema") {
		t.Error("Output should contain 'No input types exist in this schema' when no input types are present")
	}

	// Enums section should show "No enums exist" when no enums are present
	if !strings.Contains(output, "No enums exist in this schema") {
		t.Error("Output should contain 'No enums exist in this schema' when no enums are present")
	}

	// Scalars section should show "No custom scalars exist" when no custom scalars are present
	if !strings.Contains(output, "No custom scalars exist in this schema") {
		t.Error("Output should contain 'No custom scalars exist in this schema' when no custom scalars are present")
	}

	// Directives section should NOT appear when no directives are present
	if strings.Contains(output, "== Directives") {
		t.Error("Output should not contain Directives section when no directives are present")
	}

	// Should NOT contain mutation/subscription sections since schema.Mutation and schema.Subscription are nil
	notExpectedSections := []string{
		"== Mutations",
		"== Subscriptions",
	}

	for _, section := range notExpectedSections {
		if strings.Contains(output, section) {
			t.Errorf("Output should NOT contain section %q when schema doesn't define it", section)
		}
	}
}

func TestGenerateWithQuerySchema(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "query.graphql"

	// Create a simple schema with a Query type
	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "hello",
				Description: "A simple hello query",
				Type:        &ast.Type{NamedType: "String"},
			},
			&ast.FieldDefinition{
				Name:        "user",
				Description: "Get a user by ID",
				Type:        &ast.Type{NamedType: "User"},
				Arguments: ast.ArgumentDefinitionList{
					&ast.ArgumentDefinition{
						Name: "id",
						Type: &ast.Type{NamedType: "ID", NonNull: true},
					},
				},
			},
		},
	}

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "id",
				Type: &ast.Type{NamedType: "ID", NonNull: true},
			},
			&ast.FieldDefinition{
				Name: "name",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Query: queryDef,
		Types: map[string]*ast.Definition{
			"Query": queryDef,
			"User":  userDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	err := gen.Generate()
	if err != nil {
		t.Errorf("Generate() returned error: %v", err)
	}
	output := buf.String()

	// Check for query-specific content
	expectedQueryContent := []string{
		"== Query",
		"hello",
		"A simple hello query",
		"user",
		"Get a user by ID",
		"// tag::query-hello[]",
		"// tag::query-user[]",
		"[[query_hello]]",
		"[[query_user]]",
		"*Query Name:* _hello_",
		"*Query Name:* _user_",
		"*Return:* `String`",
		"*Return:* <<User,`User`>>",
	}

	for _, expected := range expectedQueryContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Query output should contain %q, but doesn't", expected)
		}
	}
}

func TestGenerateConfigFlags(t *testing.T) {
	// Create a schema with all types
	schema := createTestSchema()

	testCases := []struct {
		name             string
		configModifier   func(*config.Config)
		shouldContain    []string
		shouldNotContain []string
	}{
		{
			name: "queries disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeQueries = false
			},
			shouldNotContain: []string{"== Query"},
		},
		{
			name: "mutations disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeMutations = false
			},
			shouldNotContain: []string{"== Mutations"},
		},
		{
			name: "types disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeTypes = false
			},
			shouldNotContain: []string{"== Types"},
		},
		{
			name: "enums disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeEnums = false
			},
			shouldNotContain: []string{"== Enums"},
		},
		{
			name: "inputs disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeInputs = false
			},
			shouldNotContain: []string{"== Inputs"},
		},
		{
			name: "directives disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeDirectives = false
			},
			shouldNotContain: []string{"== Directives"},
		},
		{
			name: "scalars disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeScalars = false
			},
			shouldNotContain: []string{"== Scalars"},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			cfg := config.NewConfig()
			cfg.SchemaFile = "test.graphql"
			tc.configModifier(cfg)

			var buf bytes.Buffer
			gen := New(cfg, schema, &buf)

			gen.Generate()
			output := buf.String()

			for _, expected := range tc.shouldContain {
				if !strings.Contains(output, expected) {
					t.Errorf("Output should contain %q", expected)
				}
			}

			for _, notExpected := range tc.shouldNotContain {
				if strings.Contains(output, notExpected) {
					t.Errorf("Output should NOT contain %q", notExpected)
				}
			}
		})
	}
}

func TestGenerateQueryFieldWithArguments(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create query with arguments
	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "searchUsers",
				Description: "Search for users",
				Type:        &ast.Type{Elem: &ast.Type{NamedType: "User"}},
				Arguments: ast.ArgumentDefinitionList{
					&ast.ArgumentDefinition{
						Name:        "query",
						Description: "Search query",
						Type:        &ast.Type{NamedType: "String", NonNull: true},
					},
					&ast.ArgumentDefinition{
						Name:        "limit",
						Description: "Result limit",
						Type:        &ast.Type{NamedType: "Int"},
					},
				},
			},
		},
	}

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "name",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Query: queryDef,
		Types: map[string]*ast.Definition{
			"Query": queryDef,
			"User":  userDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.Generate()
	output := buf.String()

	expectedContent := []string{
		"searchUsers",
		"Search for users",
		"query: String! , <1>",
		"limit: Int <2>",
		"): [User] <3>",
		".Arguments",
		"`query : String!`",
		"`limit : Int`",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Output should contain %q, but doesn't. Output:\n%s", expected, output)
		}
	}
}

func TestGenerateTypes(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create schema with custom types
	userDef := &ast.Definition{
		Kind:        ast.Object,
		Name:        "User",
		Description: "A user in the system",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "id",
				Description: "User ID",
				Type:        &ast.Type{NamedType: "ID", NonNull: true},
			},
			&ast.FieldDefinition{
				Name:        "email",
				Description: "User email address",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"User": userDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.Generate()
	output := buf.String()

	expectedContent := []string{
		"== Types",
		"// tag::type-User[]",
		"[[type_user]]",
		"=== User",
		"// tag::type-description-User[]",
		"A user in the system",
		"// end::type-description-User[]",
		"// tag::type-def-User[]",
		".type: User",
		"[options=\"header\",cols=\"2a,2m,5a\"]",
		"|===",
		"| Type | Field | Description",
		"`ID!`", "id", "User ID",
		"`String`", "email", "User email address",
		"// end::type-def-User[]",
		"// end::type-User[]",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Type output should contain %q, but doesn't", expected)
		}
	}
}

func TestIsBuiltInType(t *testing.T) {
	testCases := []struct {
		typeName string
		expected bool
	}{
		{"String", true},
		{"Int", true},
		{"Float", true},
		{"Boolean", true},
		{"ID", true},
		{"Query", true},
		{"Mutation", true},
		{"Subscription", true},
		{"User", false},
		{"CustomType", false},
		{"DateTime", false},
	}

	for _, tc := range testCases {
		t.Run(tc.typeName, func(t *testing.T) {
			result := isBuiltInType(tc.typeName)
			if result != tc.expected {
				t.Errorf("isBuiltInType(%q) = %v; expected %v", tc.typeName, result, tc.expected)
			}
		})
	}
}

func TestGetTypeFieldsTableString(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "id",
				Description: "User identifier",
				Type:        &ast.Type{NamedType: "ID", NonNull: true},
			},
			&ast.FieldDefinition{
				Name:        "name",
				Description: "User full name",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	definitionsMap := map[string]*ast.Definition{
		"User": userDef,
	}

	result, err := gen.getTypeFieldsTableString(userDef, definitionsMap)
	if err != nil {
		t.Fatalf("getTypeFieldsTableString() returned error: %v", err)
	}

	expectedContent := []string{
		".type: User",
		"[options=\"header\",cols=\"2a,2m,5a\"]",
		"|===",
		"| Type | Field | Description",
		"`ID!`", "id", "User identifier",
		"`String`", "name", "User full name",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(result, expected) {
			t.Errorf("Table should contain %q, but doesn't. Result:\n%s", expected, result)
		}
	}
}

func TestExcludeInternal(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"
	cfg.ExcludeInternal = true

	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "publicQuery",
				Description: "A public query",
				Type:        &ast.Type{NamedType: "String"},
			},
			&ast.FieldDefinition{
				Name:        "internalQuery",
				Description: "INTERNAL: An internal query",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Query: queryDef,
		Types: map[string]*ast.Definition{
			"Query": queryDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.Generate()
	output := buf.String()

	// Should contain public query
	if !strings.Contains(output, "publicQuery") {
		t.Error("Output should contain public query")
	}
	if !strings.Contains(output, "A public query") {
		t.Error("Output should contain public query description")
	}

	// Should NOT contain internal query
	if strings.Contains(output, "internalQuery") {
		t.Error("Output should NOT contain internal query when ExcludeInternal is true")
	}
	if strings.Contains(output, "INTERNAL: An internal query") {
		t.Error("Output should NOT contain internal query description when ExcludeInternal is true")
	}
}

// Helper function to create a test schema with various types
func createTestSchema() *ast.Schema {
	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "hello",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	mutationDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Mutation",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "createUser",
				Type: &ast.Type{NamedType: "User"},
			},
		},
	}

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "id",
				Type: &ast.Type{NamedType: "ID"},
			},
		},
	}

	return &ast.Schema{
		Query:    queryDef,
		Mutation: mutationDef,
		Types: map[string]*ast.Definition{
			"Query":    queryDef,
			"Mutation": mutationDef,
			"User":     userDef,
		},
		Directives: make(map[string]*ast.DirectiveDefinition),
	}
}

func TestGenerateDirectives(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create a directive definition for testing
	sizeDirective := &ast.DirectiveDefinition{
		Name:        "size",
		Description: "Directive to specify size constraints",
		Arguments: []*ast.ArgumentDefinition{
			{
				Name:         "min",
				Type:         &ast.Type{NamedType: "Int"},
				DefaultValue: &ast.Value{Raw: "0", Kind: ast.IntValue},
			},
			{
				Name:         "max",
				Type:         &ast.Type{NamedType: "Int", NonNull: true},
				DefaultValue: &ast.Value{Raw: "100", Kind: ast.IntValue},
			},
		},
		Locations: []ast.DirectiveLocation{
			ast.LocationArgumentDefinition,
			ast.LocationInputFieldDefinition,
		},
		IsRepeatable: false,
	}

	schema := &ast.Schema{
		Types: make(map[string]*ast.Definition),
		Directives: map[string]*ast.DirectiveDefinition{
			"size": sizeDirective,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	err := gen.Generate()
	if err != nil {
		t.Errorf("Generate() returned error: %v", err)
	}
	output := buf.String()

	// Should contain directives section
	if !strings.Contains(output, "== Directives") {
		t.Error("Output should contain Directives section")
	}

	// Should contain directive name with @
	if !strings.Contains(output, "=== @size") {
		t.Error("Output should contain directive name with @ prefix")
	}

	// Should contain directive description
	if !strings.Contains(output, "Directive to specify size constraints") {
		t.Error("Output should contain directive description")
	}

	// Should contain directive signature
	if !strings.Contains(output, "directive @size") {
		t.Error("Output should contain directive signature")
	}

	// Should contain arguments table
	if !strings.Contains(output, "Arguments") {
		t.Error("Output should contain arguments table")
	}

	// Should contain usage locations
	if !strings.Contains(output, "Usage Locations") {
		t.Error("Output should contain usage locations")
	}

	// Should contain AsciiDoc tags
	if !strings.Contains(output, "// tag::directive-size[]") {
		t.Error("Output should contain directive AsciiDoc tags")
	}
}

func TestIsBuiltInScalar(t *testing.T) {
	testCases := []struct {
		name     string
		typeName string
		expected bool
	}{
		{"String", "String", true},
		{"Int", "Int", true},
		{"Float", "Float", true},
		{"Boolean", "Boolean", true},
		{"ID", "ID", true},
		{"Date", "Date", false},
		{"Url", "Url", false},
		{"ISO8601DateTime", "ISO8601DateTime", false},
		{"CustomScalar", "CustomScalar", false},
		{"DateTime", "DateTime", false},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := isBuiltInScalar(tc.typeName)
			if result != tc.expected {
				t.Errorf("isBuiltInScalar(%q) = %v, expected %v", tc.typeName, result, tc.expected)
			}
		})
	}
}

func TestGenerateSubscriptions(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create a schema with subscriptions
	subscriptionDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Subscription",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "userUpdates",
				Description: "Subscribe to user updates",
				Type:        &ast.Type{NamedType: "User"},
				Arguments: ast.ArgumentDefinitionList{
					&ast.ArgumentDefinition{
						Name: "userId",
						Type: &ast.Type{NamedType: "ID", NonNull: true},
					},
				},
			},
			&ast.FieldDefinition{
				Name:        "INTERNAL_test",
				Description: "INTERNAL: Test subscription",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Subscription: subscriptionDef,
		Types: map[string]*ast.Definition{
			"Subscription": subscriptionDef,
			"User": {
				Kind: ast.Object,
				Name: "User",
				Fields: ast.FieldList{
					&ast.FieldDefinition{
						Name: "id",
						Type: &ast.Type{NamedType: "ID", NonNull: true},
					},
				},
			},
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	// Test with internal filtering enabled
	cfg.ExcludeInternal = true
	count := gen.generateSubscriptions(gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 subscription, got %d", count)
	}

	output := buf.String()
	expectedContent := []string{
		"== Subscription",
		"userUpdates",
		"Subscribe to user updates",
		"// tag::subscription-userUpdates[]",
		"[[subscription_userupdates]]",
		"=== userUpdates",
		".subscription: userUpdates",
		"*Subscription Name:* _userUpdates_",
		"*Return:* <<User,`User`>>",
		"* `userId : ID!`",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Subscription output should contain %q, but doesn't", expected)
		}
	}

	// Should not contain internal subscription
	if strings.Contains(output, "INTERNAL_test") {
		t.Error("Output should not contain internal subscription when ExcludeInternal is true")
	}
}

func TestGenerateSubscriptionsEmpty(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: make(map[string]*ast.Definition),
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	count := gen.generateSubscriptions(gen.schema.Types)
	if count != 0 {
		t.Errorf("Expected 0 subscriptions, got %d", count)
	}

	output := buf.String()
	if !strings.Contains(output, "No subscriptions exist in this schema") {
		t.Error("Should show 'No subscriptions exist' message")
	}
}

func TestGetSubscriptionDetails(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"User": {
				Kind: ast.Object,
				Name: "User",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	field := &ast.FieldDefinition{
		Name:        "testSubscription",
		Description: "Test subscription description",
		Type:        &ast.Type{NamedType: "User"},
		Arguments: ast.ArgumentDefinitionList{
			&ast.ArgumentDefinition{
				Name: "id",
				Type: &ast.Type{NamedType: "ID", NonNull: true},
			},
		},
		Directives: ast.DirectiveList{
			&ast.Directive{Name: "deprecated"},
		},
	}

	details := gen.getSubscriptionDetails(field, gen.schema.Types)

	expectedContent := []string{
		"// tag::subscription-testSubscription[]",
		"[[subscription_testsubscription]]",
		"=== testSubscription",
		".subscription: testSubscription",
		"*Subscription Name:* _testSubscription_",
		"*Return:* <<User,`User`>>",
		"* `id : ID!`",
		"* @deprecated",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(details, expected) {
			t.Errorf("Subscription details should contain %q, but doesn't", expected)
		}
	}
}

func TestGenerateMutations(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create a schema with mutations
	mutationDef := &ast.Definition{
		Kind:        ast.Object,
		Name:        "Mutation",
		Description: "Root mutation type",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "createUser",
				Description: "Create a new user",
				Type:        &ast.Type{NamedType: "User"},
				Arguments: ast.ArgumentDefinitionList{
					&ast.ArgumentDefinition{
						Name: "input",
						Type: &ast.Type{NamedType: "UserInput", NonNull: true},
					},
				},
			},
			&ast.FieldDefinition{
				Name:        "INTERNAL_test",
				Description: "INTERNAL: Test mutation",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Mutation: mutationDef,
		Types: map[string]*ast.Definition{
			"Mutation": mutationDef,
			"User": {
				Kind: ast.Object,
				Name: "User",
			},
			"UserInput": {
				Kind: ast.InputObject,
				Name: "UserInput",
			},
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	// Test with internal filtering enabled
	cfg.ExcludeInternal = true
	count := gen.generateMutations(gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 mutation, got %d", count)
	}

	output := buf.String()
	// Print the actual output for debugging
	// fmt.Println("ACTUAL OUTPUT:\n" + output)
	expectedContent := []string{
		"== Mutations",
		"createUser",
		"Create a new user",
		"// tag::mutation-createUser[]",
		"[[mutation_create_user]]",
		"=== createUser",
		".mutation: createUser",
		"*Mutation Name:* _createUser_",
		"*Return:* <<User,`User`>>",
		"* `input : <<UserInput,`UserInput`>>!`",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Mutation output should contain %q, but doesn't", expected)
		}
	}

	// Should not contain internal mutation
	if strings.Contains(output, "INTERNAL_test") {
		t.Error("Output should not contain internal mutation when ExcludeInternal is true")
	}
}

func TestGenerateMutationsEmpty(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: make(map[string]*ast.Definition),
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	count := gen.generateMutations(gen.schema.Types)
	if count != 0 {
		t.Errorf("Expected 0 mutations, got %d", count)
	}

	output := buf.String()
	if !strings.Contains(output, "No mutations exist in this schema") {
		t.Error("Should show 'No mutations exist' message")
	}
}

func TestGetMethodSignatureBlock(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"User": {
				Kind: ast.Object,
				Name: "User",
			},
			"UserInput": {
				Kind: ast.InputObject,
				Name: "UserInput",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	field := &ast.FieldDefinition{
		Name: "testMutation",
		Type: &ast.Type{NamedType: "User"},
		Arguments: ast.ArgumentDefinitionList{
			&ast.ArgumentDefinition{
				Name: "input",
				Type: &ast.Type{NamedType: "UserInput", NonNull: true},
			},
			&ast.ArgumentDefinition{
				Name: "optional",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	signature := gen.getMethodSignatureBlock(field, gen.schema.Types)

	// Debug: print actual signature
	fmt.Printf("ACTUAL SIGNATURE:\n%s\n", signature)

	expectedContent := []string{
		".mutation: testMutation",
		"[source, kotlin]",
		"----",
		"testMutation(",
		"  input: UserInput! , <1>",
		"  optional: String <2>",
		") : User <3>",
		"----",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(signature, expected) {
			t.Errorf("Method signature should contain %q, but doesn't", expected)
		}
	}
}

func TestGetArgumentsBlock(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"UserInput": {
				Kind: ast.InputObject,
				Name: "UserInput",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	field := &ast.FieldDefinition{
		Name: "testMutation",
		Arguments: ast.ArgumentDefinitionList{
			&ast.ArgumentDefinition{
				Name: "input",
				Type: &ast.Type{NamedType: "UserInput", NonNull: true},
			},
			&ast.ArgumentDefinition{
				Name: "optional",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	args := gen.getArgumentsBlock(field, gen.schema.Types)

	// Debug: print actual arguments block
	fmt.Printf("ACTUAL ARGUMENTS BLOCK:\n%s\n", args)

	expectedContent := []string{
		"* `input : <<UserInput,`UserInput`>>!`",
		"* `optional : `String``",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(args, expected) {
			t.Errorf("Arguments block should contain %q, but doesn't", expected)
		}
	}
}

func TestGetArgumentsBlockEmpty(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	field := &ast.FieldDefinition{
		Name: "testMutation",
	}

	args := gen.getArgumentsBlock(field, gen.schema.Types)
	if args != "" {
		t.Errorf("Expected empty string for no arguments, got %q", args)
	}
}

func TestGetDirectivesBlock(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	field := &ast.FieldDefinition{
		Name: "testMutation",
		Directives: ast.DirectiveList{
			&ast.Directive{Name: "deprecated"},
			&ast.Directive{Name: "auth"},
		},
	}

	directives := gen.getDirectivesBlock(field)

	expectedContent := []string{
		"* @deprecated",
		"* @auth",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(directives, expected) {
			t.Errorf("Directives block should contain %q, but doesn't", expected)
		}
	}
}

func TestGetDirectivesBlockEmpty(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	field := &ast.FieldDefinition{
		Name: "testMutation",
	}

	directives := gen.getDirectivesBlock(field)
	if directives != "" {
		t.Errorf("Expected empty string for no directives, got %q", directives)
	}
}

func TestGetInputFieldsTableString(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"User": {
				Kind: ast.Object,
				Name: "User",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	inputDef := &ast.Definition{
		Kind: ast.InputObject,
		Name: "UserInput",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "name",
				Description: "User's name",
				Type:        &ast.Type{NamedType: "String", NonNull: true},
			},
			&ast.FieldDefinition{
				Name:        "email",
				Description: "User's email",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	table, err := gen.getInputFieldsTableString(inputDef, gen.schema.Types)
	if err != nil {
		t.Fatalf("getInputFieldsTableString returned error: %v", err)
	}

	// Debug: print actual table
	fmt.Printf("ACTUAL INPUT FIELDS TABLE:\n%s\n", table)

	expectedContent := []string{
		".input: UserInput",
		"[options=\"header\",cols=\"2a,2m,5a\"]",
		"|===",
		"| Field | Type | Description",
		"| `name` | `String!` | User's name",
		"| `email` | `String` | User's email",
		"|===",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(table, expected) {
			t.Errorf("Input fields table should contain %q, but doesn't", expected)
		}
	}
}

func TestGetEnumValuesTableString(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	enumDef := &ast.Definition{
		Kind: ast.Enum,
		Name: "Status",
		EnumValues: ast.EnumValueList{
			&ast.EnumValueDefinition{
				Name:        "ACTIVE",
				Description: "Active status",
			},
			&ast.EnumValueDefinition{
				Name:        "INACTIVE",
				Description: "Inactive status",
			},
		},
	}

	result, err := gen.getEnumValuesTableString(enumDef)
	if err != nil {
		t.Fatalf("getEnumValuesTableString() returned error: %v", err)
	}

	// Debug: print actual result
	fmt.Printf("ACTUAL ENUM VALUES TABLE:\n%s\n", result)

	expectedContent := []string{
		".enum: Status",
		"[options=\"header\",cols=\"1m,3a\"]",
		"|===",
		"| Value | Description",
		"| `ACTIVE` | Active status",
		"| `INACTIVE` | Inactive status",
		"|===",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(result, expected) {
			t.Errorf("Enum values table should contain %q, but doesn't", expected)
		}
	}
}

func TestGenerateEnums(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"Status": {
				Kind:        ast.Enum,
				Name:        "Status",
				Description: "User status enum",
				EnumValues: ast.EnumValueList{
					&ast.EnumValueDefinition{
						Name:        "ACTIVE",
						Description: "Active status",
					},
					&ast.EnumValueDefinition{
						Name:        "INACTIVE",
						Description: "Inactive status",
					},
				},
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	// Convert map to slice for the function call
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}

	count := gen.generateEnums(sortedDefs, gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 enum, got %d", count)
	}

	output := buf.String()
	expectedContent := []string{
		"== Enums",
		"// tag::enum-Status[]",
		"[[enum_status]]",
		"=== Status",
		"User status enum",
		"// tag::enum-def-Status[]",
		".enum: Status",
		"| `ACTIVE` | Active status",
		"| `INACTIVE` | Inactive status",
		"// end::enum-def-Status[]",
		"// end::enum-Status[]",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Enum output should contain %q, but doesn't", expected)
		}
	}
}

func TestGenerateInputs(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"UserInput": {
				Kind:        ast.InputObject,
				Name:        "UserInput",
				Description: "Input for creating a user",
				Fields: ast.FieldList{
					&ast.FieldDefinition{
						Name:        "name",
						Description: "User's name",
						Type:        &ast.Type{NamedType: "String", NonNull: true},
					},
					&ast.FieldDefinition{
						Name:        "email",
						Description: "User's email",
						Type:        &ast.Type{NamedType: "String"},
					},
				},
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	// Convert map to slice for the function call
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}

	count := gen.generateInputs(sortedDefs, gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 input, got %d", count)
	}

	output := buf.String()
	// Debug: print actual output
	fmt.Printf("ACTUAL GENERATE INPUTS OUTPUT:\n%s\n", output)
	expectedContent := []string{
		"== Inputs",
		"// tag::input-UserInput[]",
		"[[input_user_input]]",
		"=== UserInput",
		"// tag::input-description-UserInput[]",
		"Input for creating a user",
		"// end::input-description-UserInput[]",
		"// tag::input-def-UserInput[]",
		".input: UserInput",
		"| `name` | `String!` | User's name",
		"| `email` | `String` | User's email",
		"// end::input-def-UserInput[]",
		"// end::input-UserInput[]",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Input output should contain %q, but doesn't", expected)
		}
	}
}

func TestGenerateScalars(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"DateTime": {
				Kind:        ast.Scalar,
				Name:        "DateTime",
				Description: "ISO 8601 date time string",
			},
			"JSON": {
				Kind:        ast.Scalar,
				Name:        "JSON",
				Description: "JSON scalar type",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	// Convert map to slice for the function call
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}

	count := gen.generateScalars(sortedDefs)
	if count != 2 {
		t.Errorf("Expected 2 scalars, got %d", count)
	}

	output := buf.String()
	// Debug: print actual output
	fmt.Printf("ACTUAL GENERATE SCALARS OUTPUT:\n%s\n", output)
	fmt.Printf("Count: %d\n", count)
	expectedContent := []string{
		"== Scalars",
		"DateTime",
		"ISO 8601 date time string",
		"JSON",
		"JSON scalar type",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Scalar output should contain %q, but doesn't", expected)
		}
	}
}

func TestGenerateScalarsWithBuiltIn(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"String": {
				Kind: ast.Scalar,
				Name: "String",
			},
			"CustomScalar": {
				Kind:        ast.Scalar,
				Name:        "CustomScalar",
				Description: "A custom scalar",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	// Convert map to slice for the function call
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}

	count := gen.generateScalars(sortedDefs)
	if count != 1 {
		t.Errorf("Expected 1 custom scalar, got %d", count)
	}

	output := buf.String()
	// Debug: print actual output
	fmt.Printf("ACTUAL GENERATE SCALARS OUTPUT:\n%s\n", output)
	fmt.Printf("Count: %d\n", count)
	if !strings.Contains(output, "CustomScalar") {
		t.Error("Should include custom scalar 'CustomScalar'")
	}
	if strings.Contains(output, "[[scalar-String]]") {
		t.Error("Should not include built-in scalar section for 'String'")
	}
}

func TestGenerateTypesWithNoFields(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"EmptyType": {
				Kind:        ast.Object,
				Name:        "EmptyType",
				Fields:      ast.FieldList{},
				Description: "A type with no fields",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	count := gen.generateTypes(sortedDefs, gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 type, got %d", count)
	}
	output := buf.String()
	if !strings.Contains(output, "EmptyType") {
		t.Error("Output should contain type name")
	}
}

func TestGenerateEnumsWithNoValues(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"EmptyEnum": {
				Kind:        ast.Enum,
				Name:        "EmptyEnum",
				EnumValues:  ast.EnumValueList{},
				Description: "An enum with no values",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	count := gen.generateEnums(sortedDefs, gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 enum, got %d", count)
	}
	output := buf.String()
	if !strings.Contains(output, "EmptyEnum") {
		t.Error("Output should contain enum name")
	}
}

func TestGenerateScalarsWithNoDescription(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"NoDescScalar": {
				Kind:        ast.Scalar,
				Name:        "NoDescScalar",
				Description: "",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	count := gen.generateScalars(sortedDefs)
	if count != 1 {
		t.Errorf("Expected 1 scalar, got %d", count)
	}
	output := buf.String()
	if !strings.Contains(output, "NoDescScalar") {
		t.Error("Output should contain scalar name")
	}
}

func TestGenerateInputsWithNoFields(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"EmptyInput": {
				Kind:        ast.InputObject,
				Name:        "EmptyInput",
				Fields:      ast.FieldList{},
				Description: "An input with no fields",
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	count := gen.generateInputs(sortedDefs, gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 input, got %d", count)
	}
	output := buf.String()
	if !strings.Contains(output, "EmptyInput") {
		t.Error("Output should contain input name")
	}
}

func TestFieldWithOnlyChangelog(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"TypeWithChangelog": {
				Kind: ast.Object,
				Name: "TypeWithChangelog",
				Fields: ast.FieldList{
					&ast.FieldDefinition{
						Name:        "field1",
						Description: "[changelog] Added in v1.2.3",
						Type:        &ast.Type{NamedType: "String"},
					},
				},
			},
		},
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)
	var sortedDefs []*ast.Definition
	for _, def := range gen.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	count := gen.generateTypes(sortedDefs, gen.schema.Types)
	if count != 1 {
		t.Errorf("Expected 1 type, got %d", count)
	}
	output := buf.String()
	if !strings.Contains(output, "Added in v1.2.3") {
		t.Error("Output should contain changelog")
	}
}
