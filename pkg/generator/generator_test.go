package generator

import (
	"bytes"
	"strings"
	"testing"

	"github.com/vektah/gqlparser/v2/ast"

	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/config"
)

func TestNew(t *testing.T) {
	cfg := &config.Config{SchemaFile: "test.graphql"}
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer

	gen := New(cfg, schema, &buf)

	if gen == nil {
		t.Fatal("New() returned nil")
	}
	if gen.config != cfg {
		t.Error("Config not set correctly")
	}
	if gen.schema != schema {
		t.Error("Schema not set correctly")
	}
	if gen.writer != &buf {
		t.Error("Writer not set correctly")
	}
}

func TestGeneratorPrintHeader(t *testing.T) {
	cfg := &config.Config{SchemaFile: "test/schema.graphql"}
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.printHeader()
	output := buf.String()

	expectedContains := []string{
		"= GraphQL Documentation",
		":toc: left",
		":revdate:",
		":commandline:",
		":sourceFile: test/schema.graphql",
		":reproducible:",
		":page-partial:",
		":sect-anchors:",
		":table-caption!:",
		":table-stripes: even",
		":pdf-page-size: A4",
		":tags: api, GraphQL, nodes, types, query",
		"[IMPORTANT]",
		"This is automatically generated",
		"Do not edit this file directly",
	}

	for _, expected := range expectedContains {
		if !strings.Contains(output, expected) {
			t.Errorf("Header should contain %q, but doesn't. Output:\n%s", expected, output)
		}
	}
}

func TestGenerateWithEmptySchema(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "empty.graphql"
	schema := &ast.Schema{
		Types:      make(map[string]*ast.Definition),
		Directives: make(map[string]*ast.DirectiveDefinition),
	}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	err := gen.Generate()
	if err != nil {
		t.Errorf("Generate() returned error: %v", err)
	}
	output := buf.String()

	// Should at least contain header
	if !strings.Contains(output, "= GraphQL Documentation") {
		t.Error("Output should contain header")
	}

	// Should contain placeholder messages for empty sections
	expectedPlaceholders := []string{
		"Enums section - implementation in progress",
		"Inputs section - implementation in progress",
	}

	for _, placeholder := range expectedPlaceholders {
		if !strings.Contains(output, placeholder) {
			t.Errorf("Output should contain placeholder %q", placeholder)
		}
	}

	// Scalars section should show "No custom scalars exist" when no custom scalars are present
	if !strings.Contains(output, "No custom scalars exist in this schema") {
		t.Error("Output should contain 'No custom scalars exist in this schema' when no custom scalars are present")
	}

	// Directives section should NOT appear when no directives are present
	if strings.Contains(output, "== Directives") {
		t.Error("Output should not contain Directives section when no directives are present")
	}

	// Should NOT contain mutation/subscription sections since schema.Mutation and schema.Subscription are nil
	notExpectedSections := []string{
		"== Mutations",
		"== Subscriptions",
	}

	for _, section := range notExpectedSections {
		if strings.Contains(output, section) {
			t.Errorf("Output should NOT contain section %q when schema doesn't define it", section)
		}
	}
}

func TestGenerateWithQuerySchema(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "query.graphql"

	// Create a simple schema with a Query type
	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "hello",
				Description: "A simple hello query",
				Type:        &ast.Type{NamedType: "String"},
			},
			&ast.FieldDefinition{
				Name:        "user",
				Description: "Get a user by ID",
				Type:        &ast.Type{NamedType: "User"},
				Arguments: ast.ArgumentDefinitionList{
					&ast.ArgumentDefinition{
						Name: "id",
						Type: &ast.Type{NamedType: "ID", NonNull: true},
					},
				},
			},
		},
	}

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "id",
				Type: &ast.Type{NamedType: "ID", NonNull: true},
			},
			&ast.FieldDefinition{
				Name: "name",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Query: queryDef,
		Types: map[string]*ast.Definition{
			"Query": queryDef,
			"User":  userDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	err := gen.Generate()
	if err != nil {
		t.Errorf("Generate() returned error: %v", err)
	}
	output := buf.String()

	// Check for query-specific content
	expectedQueryContent := []string{
		"== Query",
		"hello",
		"A simple hello query",
		"user",
		"Get a user by ID",
		"// tag::query-hello[]",
		"// tag::query-user[]",
		"[[query_hello]]",
		"[[query_user]]",
		"*Query Name:* _hello_",
		"*Query Name:* _user_",
		"*Return:* `String`",
		"*Return:* <<User,`User`>>",
	}

	for _, expected := range expectedQueryContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Query output should contain %q, but doesn't", expected)
		}
	}
}

func TestGenerateConfigFlags(t *testing.T) {
	// Create a schema with all types
	schema := createTestSchema()

	testCases := []struct {
		name             string
		configModifier   func(*config.Config)
		shouldContain    []string
		shouldNotContain []string
	}{
		{
			name: "queries disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeQueries = false
			},
			shouldNotContain: []string{"== Query"},
		},
		{
			name: "mutations disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeMutations = false
			},
			shouldNotContain: []string{"== Mutations"},
		},
		{
			name: "types disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeTypes = false
			},
			shouldNotContain: []string{"== Types"},
		},
		{
			name: "enums disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeEnums = false
			},
			shouldNotContain: []string{"== Enums"},
		},
		{
			name: "inputs disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeInputs = false
			},
			shouldNotContain: []string{"== Inputs"},
		},
		{
			name: "directives disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeDirectives = false
			},
			shouldNotContain: []string{"== Directives"},
		},
		{
			name: "scalars disabled",
			configModifier: func(cfg *config.Config) {
				cfg.IncludeScalars = false
			},
			shouldNotContain: []string{"== Scalars"},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			cfg := config.NewConfig()
			cfg.SchemaFile = "test.graphql"
			tc.configModifier(cfg)

			var buf bytes.Buffer
			gen := New(cfg, schema, &buf)

			gen.Generate()
			output := buf.String()

			for _, expected := range tc.shouldContain {
				if !strings.Contains(output, expected) {
					t.Errorf("Output should contain %q", expected)
				}
			}

			for _, notExpected := range tc.shouldNotContain {
				if strings.Contains(output, notExpected) {
					t.Errorf("Output should NOT contain %q", notExpected)
				}
			}
		})
	}
}

func TestGenerateQueryFieldWithArguments(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create query with arguments
	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "searchUsers",
				Description: "Search for users",
				Type:        &ast.Type{Elem: &ast.Type{NamedType: "User"}},
				Arguments: ast.ArgumentDefinitionList{
					&ast.ArgumentDefinition{
						Name:        "query",
						Description: "Search query",
						Type:        &ast.Type{NamedType: "String", NonNull: true},
					},
					&ast.ArgumentDefinition{
						Name:        "limit",
						Description: "Result limit",
						Type:        &ast.Type{NamedType: "Int"},
					},
				},
			},
		},
	}

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "name",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Query: queryDef,
		Types: map[string]*ast.Definition{
			"Query": queryDef,
			"User":  userDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.Generate()
	output := buf.String()

	expectedContent := []string{
		"searchUsers",
		"Search for users",
		"query: `String!` , <1>",
		"limit: `Int` <2>",
		"): [<<User,`User`>>] <3>",
		".Arguments",
		"`query : String!`",
		"`limit : Int`",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Output should contain %q, but doesn't. Output:\n%s", expected, output)
		}
	}
}

func TestGenerateTypes(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create schema with custom types
	userDef := &ast.Definition{
		Kind:        ast.Object,
		Name:        "User",
		Description: "A user in the system",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "id",
				Description: "User ID",
				Type:        &ast.Type{NamedType: "ID", NonNull: true},
			},
			&ast.FieldDefinition{
				Name:        "email",
				Description: "User email address",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Types: map[string]*ast.Definition{
			"User": userDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.Generate()
	output := buf.String()

	expectedContent := []string{
		"== Types",
		"// tag::type-User[]",
		"[[type_user]]",
		"=== User",
		"A user in the system",
		".type: User",
		"[options=\"header\"]",
		"|===",
		"| Type | Field | Description",
		"`ID!`", "id", "User ID",
		"`String`", "email", "User email address",
		"// end::type-User[]",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(output, expected) {
			t.Errorf("Type output should contain %q, but doesn't", expected)
		}
	}
}

func TestIsBuiltInType(t *testing.T) {
	testCases := []struct {
		typeName string
		expected bool
	}{
		{"String", true},
		{"Int", true},
		{"Float", true},
		{"Boolean", true},
		{"ID", true},
		{"Query", true},
		{"Mutation", true},
		{"Subscription", true},
		{"User", false},
		{"CustomType", false},
		{"DateTime", false},
	}

	for _, tc := range testCases {
		t.Run(tc.typeName, func(t *testing.T) {
			result := isBuiltInType(tc.typeName)
			if result != tc.expected {
				t.Errorf("isBuiltInType(%q) = %v; expected %v", tc.typeName, result, tc.expected)
			}
		})
	}
}

func TestGetTypeFieldsTableString(t *testing.T) {
	cfg := config.NewConfig()
	schema := &ast.Schema{Types: make(map[string]*ast.Definition)}
	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "id",
				Description: "User identifier",
				Type:        &ast.Type{NamedType: "ID", NonNull: true},
			},
			&ast.FieldDefinition{
				Name:        "name",
				Description: "User full name",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	definitionsMap := map[string]*ast.Definition{
		"User": userDef,
	}

	result, err := gen.getTypeFieldsTableString(userDef, definitionsMap)
	if err != nil {
		t.Fatalf("getTypeFieldsTableString() returned error: %v", err)
	}

	expectedContent := []string{
		".type: User",
		"[options=\"header\"]",
		"|===",
		"| Type | Field | Description",
		"`ID!`", "id", "User identifier",
		"`String`", "name", "User full name",
	}

	for _, expected := range expectedContent {
		if !strings.Contains(result, expected) {
			t.Errorf("Table should contain %q, but doesn't. Result:\n%s", expected, result)
		}
	}
}

func TestExcludeInternal(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"
	cfg.ExcludeInternal = true

	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name:        "publicQuery",
				Description: "A public query",
				Type:        &ast.Type{NamedType: "String"},
			},
			&ast.FieldDefinition{
				Name:        "internalQuery",
				Description: "INTERNAL: An internal query",
				Type:        &ast.Type{NamedType: "String"},
			},
		},
	}

	schema := &ast.Schema{
		Query: queryDef,
		Types: map[string]*ast.Definition{
			"Query": queryDef,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	gen.Generate()
	output := buf.String()

	// Should contain public query
	if !strings.Contains(output, "publicQuery") {
		t.Error("Output should contain public query")
	}
	if !strings.Contains(output, "A public query") {
		t.Error("Output should contain public query description")
	}

	// Should NOT contain internal query
	if strings.Contains(output, "internalQuery") {
		t.Error("Output should NOT contain internal query when ExcludeInternal is true")
	}
	if strings.Contains(output, "INTERNAL: An internal query") {
		t.Error("Output should NOT contain internal query description when ExcludeInternal is true")
	}
}

// Helper function to create a test schema with various types
func createTestSchema() *ast.Schema {
	queryDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Query",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "hello",
				Type: &ast.Type{NamedType: "String"},
			},
		},
	}

	mutationDef := &ast.Definition{
		Kind: ast.Object,
		Name: "Mutation",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "createUser",
				Type: &ast.Type{NamedType: "User"},
			},
		},
	}

	userDef := &ast.Definition{
		Kind: ast.Object,
		Name: "User",
		Fields: ast.FieldList{
			&ast.FieldDefinition{
				Name: "id",
				Type: &ast.Type{NamedType: "ID"},
			},
		},
	}

	return &ast.Schema{
		Query:    queryDef,
		Mutation: mutationDef,
		Types: map[string]*ast.Definition{
			"Query":    queryDef,
			"Mutation": mutationDef,
			"User":     userDef,
		},
		Directives: make(map[string]*ast.DirectiveDefinition),
	}
}

func TestGenerateDirectives(t *testing.T) {
	cfg := config.NewConfig()
	cfg.SchemaFile = "test.graphql"

	// Create a directive definition for testing
	sizeDirective := &ast.DirectiveDefinition{
		Name:        "size",
		Description: "Directive to specify size constraints",
		Arguments: []*ast.ArgumentDefinition{
			{
				Name:         "min",
				Type:         &ast.Type{NamedType: "Int"},
				DefaultValue: &ast.Value{Raw: "0", Kind: ast.IntValue},
			},
			{
				Name:         "max",
				Type:         &ast.Type{NamedType: "Int", NonNull: true},
				DefaultValue: &ast.Value{Raw: "100", Kind: ast.IntValue},
			},
		},
		Locations: []ast.DirectiveLocation{
			ast.LocationArgumentDefinition,
			ast.LocationInputFieldDefinition,
		},
		IsRepeatable: false,
	}

	schema := &ast.Schema{
		Types: make(map[string]*ast.Definition),
		Directives: map[string]*ast.DirectiveDefinition{
			"size": sizeDirective,
		},
	}

	var buf bytes.Buffer
	gen := New(cfg, schema, &buf)

	err := gen.Generate()
	if err != nil {
		t.Errorf("Generate() returned error: %v", err)
	}
	output := buf.String()

	// Should contain directives section
	if !strings.Contains(output, "== Directives") {
		t.Error("Output should contain Directives section")
	}

	// Should contain directive name with @
	if !strings.Contains(output, "=== @size") {
		t.Error("Output should contain directive name with @ prefix")
	}

	// Should contain directive description
	if !strings.Contains(output, "Directive to specify size constraints") {
		t.Error("Output should contain directive description")
	}

	// Should contain directive signature
	if !strings.Contains(output, "directive @size") {
		t.Error("Output should contain directive signature")
	}

	// Should contain arguments table
	if !strings.Contains(output, "Arguments") {
		t.Error("Output should contain arguments table")
	}

	// Should contain usage locations
	if !strings.Contains(output, "Usage Locations") {
		t.Error("Output should contain usage locations")
	}

	// Should contain AsciiDoc tags
	if !strings.Contains(output, "// tag::directive-size[]") {
		t.Error("Output should contain directive AsciiDoc tags")
	}
}

func TestIsBuiltInScalar(t *testing.T) {
	testCases := []struct {
		name     string
		typeName string
		expected bool
	}{
		{"String", "String", true},
		{"Int", "Int", true},
		{"Float", "Float", true},
		{"Boolean", "Boolean", true},
		{"ID", "ID", true},
		{"Date", "Date", false},
		{"Url", "Url", false},
		{"ISO8601DateTime", "ISO8601DateTime", false},
		{"CustomScalar", "CustomScalar", false},
		{"DateTime", "DateTime", false},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := isBuiltInScalar(tc.typeName)
			if result != tc.expected {
				t.Errorf("isBuiltInScalar(%q) = %v, expected %v", tc.typeName, result, tc.expected)
			}
		})
	}
}
