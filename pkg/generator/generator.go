package generator

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/vektah/gqlparser/v2/ast"

	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/changelog"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/config"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/metrics"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/parser"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/templates"
)

// Generator handles AsciiDoc generation from GraphQL schemas
type Generator struct {
	config  *config.Config
	schema  *ast.Schema
	writer  io.Writer
	metrics *metrics.Metrics
}

// New creates a new Generator instance
func New(cfg *config.Config, schema *ast.Schema, writer io.Writer) *Generator {
	return &Generator{
		config:  cfg,
		schema:  schema,
		writer:  writer,
		metrics: metrics.New(cfg),
	}
}

// Generate generates the complete AsciiDoc documentation
func (g *Generator) Generate() error {
	// Check if catalogue mode is enabled
	if g.config.Catalogue {
		return g.generateCatalogue()
	}

	// Log input parameters
	g.metrics.LogInputParameters()

	// Print header
	headerTimer := g.metrics.StartSection("Header")
	g.printHeader()
	headerTimer.AddCount(1)
	headerTimer.Finish()

	// Write catalogue section (summary tables)
	catalogueTimer := g.metrics.StartSection("Catalogue")
	if err := g.writeCatalogueSection(); err != nil {
		return fmt.Errorf("error generating catalogue section: %w", err)
	}
	catalogueTimer.AddCount(1)
	catalogueTimer.Finish()

	// Create definitions map for type processing
	g.metrics.LogProgress("Setup", "Creating definitions map")
	definitionsMap := make(map[string]*ast.Definition)
	for _, def := range g.schema.Types {
		definitionsMap[def.Name] = def
	}

	// Sort definitions
	sortedDefs := make([]*ast.Definition, 0, len(g.schema.Types))
	for _, def := range g.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	sort.Slice(sortedDefs, func(i, j int) bool {
		return sortedDefs[i].Name < sortedDefs[j].Name
	})

	g.metrics.LogProgress("Setup", fmt.Sprintf("Found %d total definitions", len(g.schema.Types)))

	// Generate sections based on configuration
	if g.config.IncludeQueries && g.schema.Query != nil {
		timer := g.metrics.StartSection("Queries")
		count := g.generateQueries(definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeMutations && g.schema.Mutation != nil {
		timer := g.metrics.StartSection("Mutations")
		count := g.generateMutations(definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeSubscriptions && g.schema.Subscription != nil {
		timer := g.metrics.StartSection("Subscriptions")
		count := g.generateSubscriptions(definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeTypes {
		timer := g.metrics.StartSection("Types")
		count := g.generateTypes(sortedDefs, definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeEnums {
		timer := g.metrics.StartSection("Enums")
		count := g.generateEnums(sortedDefs, definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeInputs {
		timer := g.metrics.StartSection("Inputs")
		count := g.generateInputs(sortedDefs, definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeDirectives {
		timer := g.metrics.StartSection("Directives")
		count := g.generateDirectives(sortedDefs)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeScalars {
		timer := g.metrics.StartSection("Scalars")
		count := g.generateScalars(sortedDefs)
		timer.AddCount(count)
		timer.Finish()
	}

	// Log final metrics table
	g.metrics.LogMetricsTable()

	return nil
}

// printHeader prints the AsciiDoc document header
func (g *Generator) printHeader() {
	fmt.Fprintln(g.writer, "= GraphQL Documentation")
	fmt.Fprintln(g.writer, ":toc: left")
	fmt.Fprintf(g.writer, ":revdate: %s\n", time.Now().Format("Mon, 02 Jan 2006 15:04:05 MST"))
	fmt.Fprintf(g.writer, ":commandline: %s\n", strings.Join(os.Args, " "))
	fmt.Fprintf(g.writer, ":sourceFile: %s\n", g.config.SchemaFile)
	fmt.Fprintln(g.writer, ":reproducible:")
	fmt.Fprintln(g.writer, ":page-partial:")
	fmt.Fprintln(g.writer, ":sect-anchors:")
	fmt.Fprintln(g.writer, ":table-caption!:")
	fmt.Fprintln(g.writer, ":table-stripes: even")
	fmt.Fprintln(g.writer, ":pdf-page-size: A4")
	fmt.Fprintln(g.writer, ":tags: api, GraphQL, nodes, types, query")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[IMPORTANT]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintf(g.writer, "This is automatically generated from the schema file `%s`. +\n", g.config.SchemaFile)
	fmt.Fprintln(g.writer, "Do not edit this file directly. +")
	fmt.Fprintln(g.writer, "Last generated _{revdate}_")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

// generateQueries generates the queries section
func (g *Generator) generateQueries(definitionsMap map[string]*ast.Definition) int {
	if g.schema.Query == nil {
		return 0
	}

	g.metrics.LogProgress("Queries", "Starting query generation")

	fmt.Fprintln(g.writer, "== Query")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)
	if g.schema.Query.Description != "" {
		fmt.Fprintln(g.writer, parser.ProcessDescription(g.schema.Query.Description))
	}

	// Collect and filter queries
	var queryFields []*ast.FieldDefinition
	for _, f := range g.schema.Query.Fields {
		if !g.shouldIncludeField(f.Name, f.Description, f.Directives) {
			continue
		}
		queryFields = append(queryFields, f)
	}

	// Sort queries alphabetically by name
	sort.Slice(queryFields, func(i, j int) bool {
		return queryFields[i].Name < queryFields[j].Name
	})

	// Generate documentation for each query
	for _, f := range queryFields {
		g.generateQueryField(f, definitionsMap)
	}

	count := len(queryFields)
	g.metrics.LogProgress("Queries", fmt.Sprintf("Generated %d queries", count))
	return count
}

// generateQueryField generates documentation for a single query field
func (g *Generator) generateQueryField(field *ast.FieldDefinition, definitionsMap map[string]*ast.Definition) {
	fmt.Fprintf(g.writer, "// tag::query-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintf(g.writer, "[[query_%s]]\n", strings.ToLower(field.Name))
	fmt.Fprintf(g.writer, "=== %s\n", field.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)

	// Process description and extract changelog
	processedDesc, changelog := changelog.ProcessWithChangelog(field.Description, parser.ProcessDescription)

	// Helper to extract all list items and non-list lines
	extractLists := func(text string) (nonList, list string) {
		lines := strings.Split(text, "\n")
		var nonListLines, listLines []string
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if (strings.HasPrefix(trimmed, "- ") && !strings.HasPrefix(trimmed, "-- ")) || strings.HasPrefix(trimmed, "* ") {
				listLines = append(listLines, line)
			} else {
				nonListLines = append(nonListLines, line)
			}
		}
		return strings.Join(nonListLines, "\n"), strings.Join(listLines, "\n")
	}

	// Split the description at the Arguments marker (check both original and converted forms)
	// First, remove .Parameters: section and anything after it
	paramSplit := strings.Split(processedDesc, ".Parameters:")
	if len(paramSplit) > 1 {
		processedDesc = paramSplit[0]
	}

	parts := strings.Split(processedDesc, "**Arguments:**")
	var mainDesc, numberedRefs string

	if len(parts) == 1 {
		// No **Arguments:** found, check for .Arguments:
		parts = strings.Split(processedDesc, ".Arguments:")
		if len(parts) == 1 {
			// No .Arguments: found, check for converted .Arguments
			parts = strings.Split(processedDesc, ".Arguments")
			if len(parts) == 1 {
				// No Arguments marker at all
				mainDesc, numberedRefs = extractLists(processedDesc)
				mainDesc = parser.ConvertDashToAsterisk(mainDesc)
				if strings.TrimSpace(numberedRefs) != "" {
					numberedRefs = parser.ConvertDescriptionToRefNumbers(numberedRefs, true)
				}
			} else {
				// Found converted .Arguments marker
				mainDesc = parser.ConvertDashToAsterisk(parts[0])
				numberedRefs = parser.ConvertDescriptionToRefNumbers(parts[1], true)
			}
		} else {
			// Found .Arguments: marker
			mainDesc = parser.ConvertDashToAsterisk(parts[0])
			numberedRefs = parser.ConvertDescriptionToRefNumbers(parts[1], true)
		}
	} else {
		// Found **Arguments:** marker
		mainDesc = parser.ConvertDashToAsterisk(parts[0])
		numberedRefs = parser.ConvertDescriptionToRefNumbers(parts[1], true)
	}

	fmt.Fprintf(g.writer, "// tag::method-description-%s[]\n", field.Name)
	if strings.TrimSpace(mainDesc) != "" {
		fmt.Fprint(g.writer, strings.TrimSpace(mainDesc))
		fmt.Fprintln(g.writer)
	}
	fmt.Fprintf(g.writer, "// end::method-description-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	// Generate method signature
	fmt.Fprintf(g.writer, "// tag::method-signature-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, ".query: %s\n", field.Name)
	fmt.Fprintln(g.writer, "[source, kotlin]")
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "%s(\n", field.Name)

	// Generate arguments
	for i, arg := range field.Arguments {
		argType := parser.ProcessTypeNameForSignature(arg.Type.String(), definitionsMap)
		fmt.Fprintf(g.writer, "  %s: %s", arg.Name, argType)
		if i < len(field.Arguments)-1 {
			fmt.Fprint(g.writer, " ,")
		}
		fmt.Fprintf(g.writer, " <%d> \n", i+1)
	}

	fmt.Fprintf(g.writer, "): %s <%d>\n", parser.ProcessTypeNameForSignature(field.Type.String(), definitionsMap), len(field.Arguments)+1)
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "// end::method-signature-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	// Add numbered references from description
	fmt.Fprintf(g.writer, "// tag::method-args-%s[]\n", field.Name)
	if strings.TrimSpace(numberedRefs) != "" {
		fmt.Fprint(g.writer, strings.TrimSpace(numberedRefs))
		fmt.Fprintln(g.writer)
	}
	fmt.Fprintf(g.writer, "// end::method-args-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	fmt.Fprintf(g.writer, "// tag::query-name-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "*Query Name:* _%s_\n", field.Name)
	fmt.Fprintf(g.writer, "// end::query-name-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	fmt.Fprintf(g.writer, "// tag::query-return-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "*Return:* %s\n", parser.ProcessTypeName(field.Type.String(), definitionsMap))
	fmt.Fprintf(g.writer, "// end::query-return-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	// Add changelog section right after return
	if changelog != "" {
		fmt.Fprintf(g.writer, "// tag::query-changelog-%s[]\n", field.Name)
		fmt.Fprint(g.writer, changelog)
		fmt.Fprintln(g.writer)
		fmt.Fprintf(g.writer, "// end::query-changelog-%s[]\n", field.Name)
		fmt.Fprintln(g.writer)
	}

	if len(field.Arguments) > 0 {
		fmt.Fprintf(g.writer, "// tag::arguments-%s[]\n", field.Name)
		fmt.Fprintln(g.writer, ".Arguments")
		for _, arg := range field.Arguments {
			fmt.Fprintf(g.writer, "* `%s : %s`\n", arg.Name, arg.Type.String())
		}
		fmt.Fprintf(g.writer, "// end::arguments-%s[]\n", field.Name)
		fmt.Fprintln(g.writer)
	}

	fmt.Fprintf(g.writer, "// end::query-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)
}

// generateMutations generates the mutations section
func (g *Generator) generateMutations(definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Mutations", "Starting mutations generation")

	if g.schema.Mutation == nil || len(g.schema.Mutation.Fields) == 0 {
		// No mutations exist
		tmpl, err := template.New("mutation").Parse(templates.MutationTemplate)
		if err == nil {
			_ = tmpl.Execute(g.writer, struct {
				MutationTag               string
				MutationObjectDescription string
				FoundMutations            bool
				Mutations                 []MutationInfo
			}{
				MutationTag:               "== Mutations",
				MutationObjectDescription: "",
				FoundMutations:            false,
				Mutations:                 nil,
			})
		} else {
			fmt.Fprintln(g.writer, "== Mutations")
			fmt.Fprintln(g.writer)
			fmt.Fprintln(g.writer, "[NOTE]")
			fmt.Fprintln(g.writer, "====")
			fmt.Fprintln(g.writer, "No mutations exist in this schema.")
			fmt.Fprintln(g.writer, "====")
			fmt.Fprintln(g.writer)
		}
		g.metrics.LogProgress("Mutations", "Generated 0 mutations")
		return 0
	}

	var mutationInfos []MutationInfo
	for _, f := range g.schema.Mutation.Fields {
		if !g.shouldIncludeField(f.Name, f.Description, f.Directives) {
			continue
		}

		processedDesc, changelog := changelog.ProcessWithChangelog(f.Description, parser.ProcessDescription)

		// Helper to extract all list items and non-list lines
		extractLists := func(text string) (nonList, list string) {
			lines := strings.Split(text, "\n")
			var nonListLines, listLines []string
			for _, line := range lines {
				trimmed := strings.TrimSpace(line)
				if (strings.HasPrefix(trimmed, "- ") && !strings.HasPrefix(trimmed, "-- ")) || strings.HasPrefix(trimmed, "* ") {
					listLines = append(listLines, line)
				} else {
					nonListLines = append(nonListLines, line)
				}
			}
			return strings.Join(nonListLines, "\n"), strings.Join(listLines, "\n")
		}

		// Extract numbered references from description (similar to query processing)
		numberedRefs := ""
		if len(f.Arguments) > 0 && f.Description != "" {
			// Try to extract argument descriptions
			parts := strings.Split(processedDesc, "**Arguments:**")
			var mainDesc string

			if len(parts) == 1 {
				// No **Arguments:** found, check for .Arguments:
				parts = strings.Split(processedDesc, ".Arguments:")
				if len(parts) == 1 {
					// No .Arguments: found, check for converted .Arguments
					parts = strings.Split(processedDesc, ".Arguments")
					if len(parts) == 1 {
						// No Arguments marker at all - extract list items as arguments
						mainDesc, numberedRefs = extractLists(processedDesc)
						mainDesc = parser.ConvertDashToAsterisk(mainDesc)
						if strings.TrimSpace(numberedRefs) != "" {
							numberedRefs = parser.ConvertDescriptionToRefNumbers(numberedRefs, true)
						}
						processedDesc = mainDesc
					} else {
						// Found converted .Arguments marker
						numberedRefs = parser.ConvertDescriptionToRefNumbers(parts[1], true)
						processedDesc = parser.ConvertDashToAsterisk(parts[0])
					}
				} else {
					// Found .Arguments: marker
					numberedRefs = parser.ConvertDescriptionToRefNumbers(parts[1], true)
					processedDesc = parser.ConvertDashToAsterisk(parts[0])
				}
			} else {
				// Found **Arguments:** marker
				numberedRefs = parser.ConvertDescriptionToRefNumbers(parts[1], true)
				processedDesc = parser.ConvertDashToAsterisk(parts[0])
			}
		}

		methodSignature := g.getMethodSignatureBlock(f, definitionsMap)
		argsBlock := g.getArgumentsBlock(f, definitionsMap)
		directivesBlock := g.getDirectivesBlock(f)
		mutationInfo := MutationInfo{
			Name:                 f.Name,
			AnchorName:           "mutation_" + parser.CamelToSnake(f.Name),
			Description:          f.Description,
			CleanedDescription:   processedDesc,
			TypeName:             parser.ProcessTypeName(f.Type.String(), definitionsMap),
			MethodSignatureBlock: methodSignature,
			Arguments:            argsBlock,
			Directives:           directivesBlock,
			HasArguments:         len(f.Arguments) > 0,
			HasDirectives:        len(f.Directives) > 0,
			IsInternal:           isInternal(f.Name, f.Description),
			Changelog:            changelog,
			NumberedRefs:         numberedRefs,
		}
		mutationInfos = append(mutationInfos, mutationInfo)
	}

	// Sort mutations alphabetically by name
	sort.Slice(mutationInfos, func(i, j int) bool {
		return mutationInfos[i].Name < mutationInfos[j].Name
	})

	mutationObjectDescription := ""
	if g.schema.Mutation.Description != "" {
		mutationObjectDescription = parser.ProcessDescription(g.schema.Mutation.Description)
	}

	data := struct {
		MutationTag               string
		MutationObjectDescription string
		FoundMutations            bool
		Mutations                 []MutationInfo
	}{
		MutationTag:               "== Mutations",
		MutationObjectDescription: mutationObjectDescription,
		FoundMutations:            len(mutationInfos) > 0,
		Mutations:                 mutationInfos,
	}

	tmpl, err := template.New("mutation").Funcs(template.FuncMap{
		"printAsciiDocTagsTmpl":          func(s string) string { return s },
		"convertDescriptionToRefNumbers": func(desc string, _ bool) string { return desc },
	}).Parse(templates.MutationTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing mutation template: %v\n", err)
		g.metrics.LogProgress("Mutations", "Generated 0 mutations (template error)")
		return 0
	}

	err = tmpl.Execute(g.writer, data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing mutation template: %v\n", err)
	}

	g.metrics.LogProgress("Mutations", fmt.Sprintf("Generated %d mutations", len(mutationInfos)))
	return len(mutationInfos)
}

// Helper for mutation method signature
func (g *Generator) getMethodSignatureBlock(f *ast.FieldDefinition, definitionsMap map[string]*ast.Definition) string {
	var b strings.Builder
	fmt.Fprintf(&b, ".mutation: %s\n", f.Name)
	fmt.Fprintln(&b, "[source, kotlin]")
	fmt.Fprintln(&b, "----")
	fmt.Fprintf(&b, "%s(\n", f.Name)
	for i, arg := range f.Arguments {
		typeName := parser.ProcessTypeNameForSignature(arg.Type.String(), definitionsMap)
		fmt.Fprintf(&b, "  %s: %s", arg.Name, typeName)
		if i < len(f.Arguments)-1 {
			fmt.Fprint(&b, " ,")
		}
		fmt.Fprintf(&b, " <%d> \n", i+1)
	}
	fmt.Fprintf(&b, "): %s <%d>\n", parser.ProcessTypeNameForSignature(f.Type.String(), definitionsMap), len(f.Arguments)+1)
	fmt.Fprint(&b, "----")
	return b.String()
}

// Helper for mutation arguments block
func (g *Generator) getArgumentsBlock(f *ast.FieldDefinition, definitionsMap map[string]*ast.Definition) string {
	if len(f.Arguments) == 0 {
		return ""
	}
	var b strings.Builder
	for _, arg := range f.Arguments {
		typeName := parser.ProcessTypeName(arg.Type.String(), definitionsMap)
		fmt.Fprintf(&b, "* `%s : %s`\n", arg.Name, typeName)
	}
	return b.String()
}

// Helper for mutation directives block
func (g *Generator) getDirectivesBlock(f *ast.FieldDefinition) string {
	if len(f.Directives) == 0 {
		return ""
	}
	var b strings.Builder
	for _, d := range f.Directives {
		fmt.Fprintf(&b, "* @%s\n", d.Name)
	}
	return b.String()
}

// generateSubscriptions generates the subscriptions section
func (g *Generator) generateSubscriptions(definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Subscriptions", "Starting subscriptions generation")

	if g.schema.Subscription == nil || len(g.schema.Subscription.Fields) == 0 {
		// No subscriptions exist
		tmpl, err := template.New("subscription").Parse(templates.SubscriptionTemplate)
		if err == nil {
			_ = tmpl.Execute(g.writer, struct {
				FoundSubscriptions bool
				Subscriptions      []SubscriptionInfo
			}{
				FoundSubscriptions: false,
				Subscriptions:      nil,
			})
		} else {
			fmt.Fprintln(g.writer, "== Subscription")
			fmt.Fprintln(g.writer)
			fmt.Fprintln(g.writer, "[NOTE]")
			fmt.Fprintln(g.writer, "====")
			fmt.Fprintln(g.writer, "No subscriptions exist in this schema.")
			fmt.Fprintln(g.writer, "====")
			fmt.Fprintln(g.writer)
		}
		g.metrics.LogProgress("Subscriptions", "Generated 0 subscriptions")
		return 0
	}

	// Collect and filter subscriptions
	var subscriptionFields []*ast.FieldDefinition
	for _, f := range g.schema.Subscription.Fields {
		if !g.shouldIncludeField(f.Name, f.Description, f.Directives) {
			continue
		}
		subscriptionFields = append(subscriptionFields, f)
	}

	// Sort subscriptions alphabetically by name
	sort.Slice(subscriptionFields, func(i, j int) bool {
		return subscriptionFields[i].Name < subscriptionFields[j].Name
	})

	// Generate subscription info for each subscription
	var subscriptionInfos []SubscriptionInfo
	for _, f := range subscriptionFields {
		processedDesc, _ := changelog.ProcessWithChangelog(f.Description, parser.ProcessDescription)
		details := g.getSubscriptionDetails(f, definitionsMap)

		subscriptionInfo := SubscriptionInfo{
			Description: processedDesc,
			Details:     details,
		}
		subscriptionInfos = append(subscriptionInfos, subscriptionInfo)
	}

	data := struct {
		FoundSubscriptions bool
		Subscriptions      []SubscriptionInfo
	}{
		FoundSubscriptions: len(subscriptionInfos) > 0,
		Subscriptions:      subscriptionInfos,
	}

	tmpl, err := template.New("subscription").Funcs(template.FuncMap{
		"printAsciiDocTagsTmpl": func(s string) string { return s },
	}).Parse(templates.SubscriptionTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing subscription template: %v\n", err)
		g.metrics.LogProgress("Subscriptions", "Generated 0 subscriptions (template error)")
		return 0
	}

	err = tmpl.Execute(g.writer, data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing subscription template: %v\n", err)
	}

	g.metrics.LogProgress("Subscriptions", fmt.Sprintf("Generated %d subscriptions", len(subscriptionInfos)))
	return len(subscriptionInfos)
}

// Helper for subscription details
func (g *Generator) getSubscriptionDetails(f *ast.FieldDefinition, definitionsMap map[string]*ast.Definition) string {
	var b strings.Builder

	// Generate subscription signature
	fmt.Fprintf(&b, "// tag::subscription-%s[]\n", f.Name)
	fmt.Fprintln(&b)
	fmt.Fprintf(&b, "[[subscription_%s]]\n", strings.ToLower(f.Name))
	fmt.Fprintf(&b, "=== %s\n", f.Name)
	fmt.Fprintln(&b)
	fmt.Fprintln(&b)

	// Generate method signature
	fmt.Fprintf(&b, "// tag::subscription-signature-%s[]\n", f.Name)
	fmt.Fprintf(&b, ".subscription: %s\n", f.Name)
	fmt.Fprintln(&b, "[source, kotlin]")
	fmt.Fprintln(&b, "----")
	fmt.Fprintf(&b, "%s(\n", f.Name)

	// Generate arguments
	for i, arg := range f.Arguments {
		argType := parser.ProcessTypeNameForSignature(arg.Type.String(), definitionsMap)
		fmt.Fprintf(&b, "  %s: %s", arg.Name, argType)
		if i < len(f.Arguments)-1 {
			fmt.Fprint(&b, " ,")
		}
		fmt.Fprintf(&b, " <%d> \n", i+1)
	}

	fmt.Fprintf(&b, "): %s <%d>\n", parser.ProcessTypeNameForSignature(f.Type.String(), definitionsMap), len(f.Arguments)+1)
	fmt.Fprintln(&b, "----")
	fmt.Fprintf(&b, "// end::subscription-signature-%s[]\n", f.Name)
	fmt.Fprintln(&b)

	// Add subscription name
	fmt.Fprintf(&b, "// tag::subscription-name-%s[]\n", f.Name)
	fmt.Fprintf(&b, "*Subscription Name:* _%s_\n", f.Name)
	fmt.Fprintf(&b, "// end::subscription-name-%s[]\n", f.Name)
	fmt.Fprintln(&b)

	// Add return type
	fmt.Fprintf(&b, "// tag::subscription-return-%s[]\n", f.Name)
	fmt.Fprintf(&b, "*Return:* %s\n", parser.ProcessTypeName(f.Type.String(), definitionsMap))
	fmt.Fprintf(&b, "// end::subscription-return-%s[]\n", f.Name)
	fmt.Fprintln(&b)

	// Add arguments if any
	if len(f.Arguments) > 0 {
		fmt.Fprintf(&b, "// tag::subscription-arguments-%s[]\n", f.Name)
		fmt.Fprintln(&b, ".Arguments")
		for _, arg := range f.Arguments {
			fmt.Fprintf(&b, "* `%s : %s`\n", arg.Name, arg.Type.String())
		}
		fmt.Fprintf(&b, "// end::subscription-arguments-%s[]\n", f.Name)
		fmt.Fprintln(&b)
	}

	// Add directives if any
	if len(f.Directives) > 0 {
		fmt.Fprintf(&b, "// tag::subscription-directives-%s[]\n", f.Name)
		fmt.Fprintln(&b, ".Directives")
		for _, d := range f.Directives {
			fmt.Fprintf(&b, "* @%s\n", d.Name)
		}
		fmt.Fprintf(&b, "// end::subscription-directives-%s[]\n", f.Name)
		fmt.Fprintln(&b)
	}

	fmt.Fprintf(&b, "// end::subscription-%s[]\n", f.Name)
	fmt.Fprintln(&b)

	return b.String()
}

func (g *Generator) generateTypes(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Types", "Starting types generation")

	var typeInfos []TypeInfo
	count := 0

	for _, t := range sortedDefs {
		if t.Kind == ast.Object && !isBuiltInType(t.Name) {
			// Generate fields table
			fieldsTableString, err := g.getTypeFieldsTableString(t, definitionsMap)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error generating fields table for type %s: %v\n", t.Name, err)
				fieldsTableString = "[ERROR generating fields table]"
			}

			// Process type description and extract changelog
			processedDesc, changelog := changelog.ProcessWithChangelog(t.Description, parser.ProcessDescription)

			typeInfo := TypeInfo{
				Name:        t.Name,
				Kind:        string(t.Kind),
				AnchorName:  "type_" + parser.CamelToSnake(t.Name),
				Description: processedDesc,
				FieldsTable: fieldsTableString,
				IsInterface: t.Kind == ast.Interface,
				Changelog:   changelog,
			}
			typeInfos = append(typeInfos, typeInfo)
			count++
		}
	}

	if len(typeInfos) > 0 {
		data := struct {
			TypesTag string
			Types    []TypeInfo
		}{
			TypesTag: "== Types",
			Types:    typeInfos,
		}

		tmpl, err := template.New("types").Funcs(template.FuncMap{
			"printAsciiDocTagsTmpl": func(s string) string { return s },
		}).Parse(templates.TypeSectionTemplate)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing type section template: %v\n", err)
			g.metrics.LogProgress("Types", fmt.Sprintf("Generated %d types", count))
			return count
		}

		err = tmpl.Execute(g.writer, data)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error executing type section template: %v\n", err)
		}
	}

	g.metrics.LogProgress("Types", fmt.Sprintf("Generated %d types", count))
	return count
}

func (g *Generator) generateEnums(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Enums", "Starting enums generation")

	var enumInfos []EnumInfo
	count := 0

	// Filter for enum definitions
	for _, def := range sortedDefs {
		if def.Kind == ast.Enum {
			// Generate values table
			valuesTableString, err := g.getEnumValuesTableString(def)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error generating values table for enum %s: %v\n", def.Name, err)
				valuesTableString = "[ERROR generating values table]"
			}

			// Process enum description and extract changelog
			processedDesc, _ := changelog.ProcessWithChangelog(def.Description, parser.ProcessDescription)

			enumInfo := EnumInfo{
				Name:        def.Name,
				AnchorName:  "enum_" + parser.CamelToSnake(def.Name),
				Description: processedDesc,
				ValuesTable: valuesTableString,
			}
			enumInfos = append(enumInfos, enumInfo)
			count++
		}
	}

	if len(enumInfos) > 0 {
		data := struct {
			EnumsTag string
			Enums    []EnumInfo
		}{
			EnumsTag: "== Enums",
			Enums:    enumInfos,
		}

		tmpl, err := template.New("enums").Funcs(template.FuncMap{
			"printAsciiDocTagsTmpl": func(s string) string { return s },
		}).Parse(templates.EnumSectionTemplate)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing enum section template: %v\n", err)
			g.metrics.LogProgress("Enums", fmt.Sprintf("Generated %d enums", count))
			return count
		}

		err = tmpl.Execute(g.writer, data)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error executing enum section template: %v\n", err)
		}
	} else {
		// No enums found, write a note
		fmt.Fprintln(g.writer, "== Enums")
		fmt.Fprintln(g.writer)
		fmt.Fprintln(g.writer, "[NOTE]")
		fmt.Fprintln(g.writer, "====")
		fmt.Fprintln(g.writer, "No enums exist in this schema.")
		fmt.Fprintln(g.writer, "====")
		fmt.Fprintln(g.writer)
	}

	g.metrics.LogProgress("Enums", fmt.Sprintf("Generated %d enums", count))
	return count
}

func (g *Generator) generateInputs(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Inputs", "Starting inputs generation")

	var inputInfos []InputInfo
	count := 0

	// Filter for input object definitions
	for _, def := range sortedDefs {
		if def.Kind == ast.InputObject {
			fieldsTableString, err := g.getInputFieldsTableString(def, definitionsMap)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error generating fields table for input %s: %v\n", def.Name, err)
				fieldsTableString = "[ERROR generating fields table]"
			}

			processedDesc, changelog := changelog.ProcessWithChangelog(def.Description, parser.ProcessDescription)

			inputInfo := InputInfo{
				Name:        def.Name,
				AnchorName:  "input_" + parser.CamelToSnake(def.Name),
				Description: processedDesc,
				FieldsTable: fieldsTableString,
				Changelog:   changelog,
			}
			inputInfos = append(inputInfos, inputInfo)
			count++
		}
	}

	if len(inputInfos) > 0 {
		data := struct {
			InputsTag string
			Inputs    []InputInfo
		}{
			InputsTag: "== Inputs",
			Inputs:    inputInfos,
		}

		tmpl, err := template.New("inputs").Funcs(template.FuncMap{
			"printAsciiDocTagsTmpl": func(s string) string { return s },
		}).Parse(templates.InputSectionTemplate)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing input section template: %v\n", err)
			g.metrics.LogProgress("Inputs", fmt.Sprintf("Generated %d inputs", count))
			return count
		}

		err = tmpl.Execute(g.writer, data)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error executing input section template: %v\n", err)
		}
	} else {
		fmt.Fprintln(g.writer, "== Inputs")
		fmt.Fprintln(g.writer)
		fmt.Fprintln(g.writer, "[NOTE]")
		fmt.Fprintln(g.writer, "====")
		fmt.Fprintln(g.writer, "No input types exist in this schema.")
		fmt.Fprintln(g.writer, "====")
		fmt.Fprintln(g.writer)
	}

	g.metrics.LogProgress("Inputs", fmt.Sprintf("Generated %d inputs", count))
	return count
}

func (g *Generator) getInputFieldsTableString(def *ast.Definition, definitionsMap map[string]*ast.Definition) (string, error) {
	var builder strings.Builder

	builder.WriteString(".input: " + def.Name + "\n")
	builder.WriteString("[options=\"header\",cols=\"2a,2m,5a\"]\n")
	builder.WriteString("|===\n")
	builder.WriteString("| Field | Type | Description \n")

	for _, field := range def.Fields {
		typeName := parser.ProcessTypeName(field.Type.String(), definitionsMap)
		processedDesc, changelog := changelog.ProcessWithChangelog(field.Description, parser.ProcessDescription)
		desc := processedDesc
		if changelog != "" {
			desc += "\n" + changelog
		}
		fmt.Fprintf(&builder, "| `%s` | %s | %s\n", field.Name, typeName, desc)
	}

	builder.WriteString("|===\n")
	return builder.String(), nil
}

func (g *Generator) generateDirectives(sortedDefs []*ast.Definition) int {
	g.metrics.LogProgress("Directives", "Starting directives generation")

	if len(g.schema.Directives) == 0 {
		g.metrics.LogProgress("Directives", "No directives found")
		return 0
	}

	fmt.Fprintln(g.writer, "== Directives")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "// tag::DIRECTIVES[]")
	fmt.Fprintln(g.writer)

	// Sort directives by name for consistent output
	var directiveNames []string
	for name := range g.schema.Directives {
		directiveNames = append(directiveNames, name)
	}
	sort.Strings(directiveNames)

	count := 0
	for _, name := range directiveNames {
		directive := g.schema.Directives[name]
		g.generateDirective(directive)
		count++
	}

	fmt.Fprintln(g.writer, "// end::DIRECTIVES[]")

	g.metrics.LogProgress("Directives", fmt.Sprintf("Generated %d directives", count))
	return count
}

// generateDirective generates documentation for a single directive
func (g *Generator) generateDirective(directive *ast.DirectiveDefinition) {
	fmt.Fprintf(g.writer, "// tag::directive-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintf(g.writer, "[[directive_%s]]\n", strings.ToLower(directive.Name))
	fmt.Fprintf(g.writer, "=== @%s\n", directive.Name)
	fmt.Fprintln(g.writer)

	// Process description
	if directive.Description != "" {
		processedDesc := parser.ProcessDescription(directive.Description)
		fmt.Fprintf(g.writer, "// tag::directive-description-%s[]\n", directive.Name)
		fmt.Fprint(g.writer, processedDesc)
		fmt.Fprintln(g.writer)
		fmt.Fprintf(g.writer, "// end::directive-description-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	// Generate directive signature
	fmt.Fprintf(g.writer, "// tag::directive-signature-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer, ".Directive Signature")
	fmt.Fprintln(g.writer, "[source, graphql]")
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "directive @%s", directive.Name)

	if len(directive.Arguments) > 0 {
		fmt.Fprint(g.writer, "(")
		for i, arg := range directive.Arguments {
			if i > 0 {
				fmt.Fprint(g.writer, ", ")
			}
			fmt.Fprintf(g.writer, "%s: %s", arg.Name, arg.Type.String())
			if arg.DefaultValue != nil {
				fmt.Fprintf(g.writer, " = %s", arg.DefaultValue.String())
			}
		}
		fmt.Fprint(g.writer, ")")
	}

	if len(directive.Locations) > 0 {
		fmt.Fprint(g.writer, " on ")
		for i, location := range directive.Locations {
			if i > 0 {
				fmt.Fprint(g.writer, " | ")
			}
			fmt.Fprint(g.writer, string(location))
		}
	}

	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "// end::directive-signature-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer)

	// Generate arguments table if there are arguments
	if len(directive.Arguments) > 0 {
		fmt.Fprintf(g.writer, "// tag::directive-arguments-%s[]\n", directive.Name)
		fmt.Fprintf(g.writer, ".@%s Arguments\n", directive.Name)
		fmt.Fprintln(g.writer, "[options=\"header\",stripes=\"even\"]")
		fmt.Fprintln(g.writer, "|===")
		fmt.Fprintln(g.writer, "| Argument | Type | Default | Description")

		for _, arg := range directive.Arguments {
			fmt.Fprintf(g.writer, "| `%s`", arg.Name)
			fmt.Fprintf(g.writer, " | `%s`", arg.Type.String())

			// Default value
			if arg.DefaultValue != nil {
				fmt.Fprintf(g.writer, " | `%s`", arg.DefaultValue.String())
			} else {
				fmt.Fprint(g.writer, " | _none_")
			}

			// Description
			if arg.Description != "" {
				processedDesc := parser.ProcessDescription(arg.Description)
				fmt.Fprintf(g.writer, " | %s", processedDesc)
			} else {
				fmt.Fprint(g.writer, " | _No description_")
			}
			fmt.Fprintln(g.writer)
		}

		fmt.Fprintln(g.writer, "|===")
		fmt.Fprintf(g.writer, "// end::directive-arguments-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	// Generate locations information
	if len(directive.Locations) > 0 {
		fmt.Fprintf(g.writer, "// tag::directive-locations-%s[]\n", directive.Name)
		fmt.Fprintf(g.writer, ".@%s Usage Locations\n", directive.Name)
		for _, location := range directive.Locations {
			fmt.Fprintf(g.writer, "* `%s`\n", string(location))
		}
		fmt.Fprintf(g.writer, "// end::directive-locations-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	// Repeatable information
	if directive.IsRepeatable {
		fmt.Fprintf(g.writer, "// tag::directive-repeatable-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer, "NOTE: This directive is repeatable and can be used multiple times on the same element.")
		fmt.Fprintf(g.writer, "// end::directive-repeatable-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	fmt.Fprintf(g.writer, "// end::directive-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer)
}

func (g *Generator) generateScalars(sortedDefs []*ast.Definition) int {
	g.metrics.LogProgress("Scalars", "Starting scalars generation")

	var scalarInfos []ScalarInfo
	count := 0

	// Filter for scalar definitions and exclude built-in scalars
	for _, def := range sortedDefs {
		if def.Kind == ast.Scalar && !isBuiltInScalar(def.Name) {
			// Process description and extract changelog
			processedDesc, _ := changelog.ProcessWithChangelog(def.Description, parser.ProcessDescription)

			scalarInfo := ScalarInfo{
				Name:        def.Name,
				Description: processedDesc,
			}
			scalarInfos = append(scalarInfos, scalarInfo)
			count++
		}
	}

	// Prepare data for template
	data := ScalarData{
		ScalarTag:    "== Scalars",
		FoundScalars: len(scalarInfos) > 0,
		Scalars:      scalarInfos,
	}

	// Execute template
	tmpl, err := template.New("scalars").Funcs(template.FuncMap{
		"printAsciiDocTagsTmpl": func(s string) string { return s },
	}).Parse(templates.ScalarTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing scalar template: %v\n", err)
		g.metrics.LogProgress("Scalars", fmt.Sprintf("Generated %d scalars", count))
		return count
	}

	err = tmpl.Execute(g.writer, data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing scalar template: %v\n", err)
	}

	g.metrics.LogProgress("Scalars", fmt.Sprintf("Generated %d scalars", count))
	return count
}

// Helper functions
func (g *Generator) getTypeFieldsTableString(t *ast.Definition, definitionsMap map[string]*ast.Definition) (string, error) {
	var builder strings.Builder

	builder.WriteString(".type: " + t.Name + "\n")
	builder.WriteString("[options=\"header\",cols=\"2a,2m,5a\"]\n")
	builder.WriteString("|===\n")
	builder.WriteString("| Type | Field | Description \n")

	for _, f := range t.Fields {
		typeName := parser.ProcessTypeName(f.Type.String(), definitionsMap)
		processedDesc, changelog := changelog.ProcessWithChangelog(f.Description, parser.ProcessDescription)

		data := FieldData{
			Type:            typeName,
			Name:            f.Name,
			Description:     processedDesc,
			RequiredOrArray: strings.Contains(typeName, "!") || strings.Contains(typeName, "["),
			Changelog:       changelog,
		}

		tmpl, err := template.New("field").Funcs(template.FuncMap{
			"processDescription": parser.ProcessDescription,
		}).Parse(templates.FieldTemplate)
		if err != nil {
			return "", err
		}

		err = tmpl.Execute(&builder, data)
		if err != nil {
			return "", err
		}
	}

	builder.WriteString("|===\n")
	return builder.String(), nil
}

func (g *Generator) getEnumValuesTableString(e *ast.Definition) (string, error) {
	var builder strings.Builder

	builder.WriteString(".enum: " + e.Name + "\n")
	builder.WriteString("[options=\"header\",cols=\"1m,3a\"]\n")
	builder.WriteString("|===\n")
	builder.WriteString("| Value | Description \n")

	for _, value := range e.EnumValues {
		processedDesc := parser.ProcessDescription(value.Description)
		fmt.Fprintf(&builder, "| `%s` | %s\n", value.Name, processedDesc)
	}

	builder.WriteString("|===\n")
	return builder.String(), nil
}

func isBuiltInType(typeName string) bool {
	builtInTypes := map[string]bool{
		"String":       true,
		"Int":          true,
		"Float":        true,
		"Boolean":      true,
		"ID":           true,
		"Query":        true,
		"Mutation":     true,
		"Subscription": true,
	}
	return builtInTypes[typeName]
}

func isBuiltInScalar(typeName string) bool {
	builtInScalars := map[string]bool{
		"String":  true,
		"Int":     true,
		"Float":   true,
		"Boolean": true,
		"ID":      true,
	}
	return builtInScalars[typeName]
}

// isInternal checks if a field is internal based on name or description
// A field is considered internal if:
// - Its name starts with "internal" (case-insensitive)
// - Its description contains "INTERNAL" (case-insensitive)
func isInternal(name string, description string) bool {
	// Check if name starts with "internal"
	if strings.HasPrefix(strings.ToLower(name), "internal") {
		return true
	}

	// Check if description contains "INTERNAL"
	if strings.Contains(strings.ToUpper(description), "INTERNAL") {
		return true
	}

	return false
}

// isDeprecated checks if a field is deprecated
// A field is considered deprecated if:
// - It has a @deprecated directive (checked via directives parameter)
// - Its description contains "@deprecated" or "deprecated" (case-insensitive)
func isDeprecated(description string, directives ast.DirectiveList) bool {
	// Check if field has @deprecated directive
	for _, d := range directives {
		if strings.ToLower(d.Name) == "deprecated" {
			return true
		}
	}

	// Check if description contains deprecation markers
	descUpper := strings.ToUpper(description)
	if strings.Contains(descUpper, "@DEPRECATED") || strings.Contains(descUpper, "DEPRECATED") {
		return true
	}

	return false
}

// isPreview checks if a field is in preview status
// A field is considered preview if:
// - Its description contains "PREVIEW" or "preview" markers
func isPreview(description string) bool {
	// Check if description contains "PREVIEW"
	if strings.Contains(strings.ToUpper(description), "PREVIEW") {
		return true
	}

	return false
}

// isLegacy checks if a field is legacy
// A field is considered legacy if:
// - Its description contains "LEGACY" or "legacy" markers
func isLegacy(description string) bool {
	// Check if description contains "LEGACY"
	if strings.Contains(strings.ToUpper(description), "LEGACY") {
		return true
	}

	return false
}

// isZeroVersion checks if a field has version 0.0.0 or 0.0.0.0
// A field is considered zero version if:
// - Its description contains "@version: 0.0.0" or "@version: 0.0.0.0"
// - Also matches variations like "add.version: 0.0.0", "update.version: 0.0.0", etc.
func isZeroVersion(description string) bool {
	// Check for @version: 0.0.0 or @version: 0.0.0.0
	if strings.Contains(description, "@version: 0.0.0") || strings.Contains(description, "@version: 0.0.0.0") {
		return true
	}

	// Check for add.version, update.version, etc.
	versionPatterns := []string{
		"add.version: 0.0.0",
		"update.version: 0.0.0",
		"delete.version: 0.0.0",
		"save.version: 0.0.0",
		"remove.version: 0.0.0",
		"create.version: 0.0.0",
		"deprecated.version: 0.0.0",
		"add.version: 0.0.0.0",
		"update.version: 0.0.0.0",
		"delete.version: 0.0.0.0",
		"save.version: 0.0.0.0",
		"remove.version: 0.0.0.0",
		"create.version: 0.0.0.0",
		"deprecated.version: 0.0.0.0",
	}

	for _, pattern := range versionPatterns {
		if strings.Contains(description, pattern) {
			return true
		}
	}

	return false
}

// shouldIncludeField checks if a field should be included based on the configuration settings.
// This consolidates the filtering logic for queries, mutations, and subscriptions.
func (g *Generator) shouldIncludeField(name, description string, directives ast.DirectiveList) bool {
	if !g.config.IncludeInternal && isInternal(name, description) {
		return false
	}
	if !g.config.IncludeDeprecated && isDeprecated(description, directives) {
		return false
	}
	if !g.config.IncludePreview && isPreview(description) {
		return false
	}
	if !g.config.IncludeLegacy && isLegacy(description) {
		return false
	}
	if !g.config.IncludeZeroVersion && isZeroVersion(description) {
		return false
	}
	return true
}

// collectCatalogueData collects and organizes catalogue data for queries, mutations, and subscriptions
func (g *Generator) collectCatalogueData() CatalogueData {
	var queries []CatalogueEntry
	var mutations []CatalogueEntry
	var subscriptions []CatalogueEntry

	// Collect queries
	if g.schema.Query != nil {
		for _, field := range g.schema.Query.Fields {
			if !g.shouldIncludeField(field.Name, field.Description, field.Directives) {
				continue
			}

			var description, changelogText string
			if g.config.IncludeChangelog {
				processedDesc, changelogResult := changelog.ProcessWithChangelog(field.Description, parser.ProcessDescription)
				description = parser.ExtractFirstSentence(processedDesc)
				changelogText = changelogResult
			} else {
				description = parser.ExtractFirstSentence(field.Description)
			}

			queries = append(queries, CatalogueEntry{
				Name:        field.Name,
				Description: description,
				Changelog:   changelogText,
			})
		}
	}

	// Collect mutations
	if g.schema.Mutation != nil {
		for _, field := range g.schema.Mutation.Fields {
			if !g.shouldIncludeField(field.Name, field.Description, field.Directives) {
				continue
			}

			var description, changelogText string
			if g.config.IncludeChangelog {
				processedDesc, changelogResult := changelog.ProcessWithChangelog(field.Description, parser.ProcessDescription)
				description = parser.ExtractFirstSentence(processedDesc)
				changelogText = changelogResult
			} else {
				description = parser.ExtractFirstSentence(field.Description)
			}

			mutations = append(mutations, CatalogueEntry{
				Name:        field.Name,
				Description: description,
				Changelog:   changelogText,
			})
		}
	}

	// Collect subscriptions
	if g.schema.Subscription != nil {
		for _, field := range g.schema.Subscription.Fields {
			if !g.shouldIncludeField(field.Name, field.Description, field.Directives) {
				continue
			}

			var description, changelogText string
			if g.config.IncludeChangelog {
				processedDesc, changelogResult := changelog.ProcessWithChangelog(field.Description, parser.ProcessDescription)
				description = parser.ExtractFirstSentence(processedDesc)
				changelogText = changelogResult
			} else {
				description = parser.ExtractFirstSentence(field.Description)
			}

			subscriptions = append(subscriptions, CatalogueEntry{
				Name:        field.Name,
				Description: description,
				Changelog:   changelogText,
			})
		}
	}

	// Sort queries alphabetically by name
	sort.Slice(queries, func(i, j int) bool {
		return queries[i].Name < queries[j].Name
	})

	// Sort mutations alphabetically by name
	sort.Slice(mutations, func(i, j int) bool {
		return mutations[i].Name < mutations[j].Name
	})

	// Group mutations by type
	mutationGroups := groupMutationsByType(mutations)

	// Sort subscriptions alphabetically by name
	sort.Slice(subscriptions, func(i, j int) bool {
		return subscriptions[i].Name < subscriptions[j].Name
	})

	// Return the catalogue data
	return CatalogueData{
		SubTitle:       g.config.SubTitle,
		RevDate:        time.Now().Format("Mon, 02 Jan 2006 15:04:05 MST"),
		CommandLine:    strings.Join(os.Args, " "),
		Queries:        queries,
		Mutations:      mutations,
		MutationGroups: mutationGroups,
		Subscriptions:  subscriptions,
	}
}

// writeCatalogueSection writes the catalogue tables section to the output
// This is used in standard documentation mode to include catalogue at the top
func (g *Generator) writeCatalogueSection() error {
	// Skip catalogue section if all components are disabled
	if !g.config.IncludeQueries && !g.config.IncludeMutations && !g.config.IncludeSubscriptions {
		return nil
	}

	data := g.collectCatalogueData()

	// Build template based on what's enabled
	var templateParts []string

	// Add queries section if enabled and schema defines queries
	if g.config.IncludeQueries && g.schema.Query != nil {
		querySection := `== Queries

*Queries* are how clients *read or fetch data* in GraphQL.
They describe _what_ data the client wants, not _how_ to get it.

The following table provides a quick reference to all available queries in the GraphQL API.

{{- if .Queries }}

[options="header",cols="2m,5a"]
|===
| Name | Description
{{- range .Queries }}
| {{.Name}} | {{.Description}}{{if .Changelog}}
{{.Changelog}}{{end}}
{{- end }}
|===
{{- else }}

[NOTE]
====
No queries exist in this schema.
====
{{- end }}

`
		templateParts = append(templateParts, querySection)
	}

	// Add mutations section if enabled and schema defines mutations
	if g.config.IncludeMutations && g.schema.Mutation != nil {
		mutationSection := `
== Mutations


*Mutations* are how clients *write or modify data* for example, creating, updating, or deleting records.

A mutation looks similar to a query, but it describes an action that changes data.

The following table provides a quick reference to all available mutations in the GraphQL API.

{{- if .MutationGroups }}

[options="header",cols="2m,5a"]
|===
| Name | Description
{{- range .MutationGroups }}
2+^h| {{.GroupName}}
{{- range .Mutations }}
| {{.Name}} | {{.Description}}{{if .Changelog}}
{{.Changelog}}{{end}}
{{- end }}
{{- end }}
|===
{{- else if .Mutations }}

[options="header",cols="2m,5a"]
|===
| Name | Description
{{- range .Mutations }}
| {{.Name}} | {{.Description}}{{if .Changelog}}
{{.Changelog}}{{end}}
{{- end }}
|===
{{- else }}

[NOTE]
====
No mutations exist in this schema.
====
{{- end }}

`
		templateParts = append(templateParts, mutationSection)
	}

	// Add subscriptions section if enabled and schema defines subscriptions
	if g.config.IncludeSubscriptions && g.schema.Subscription != nil {
		subscriptionSection := `== Subscriptions

{{- if .Subscriptions }}

The following table provides a quick reference to all available subscriptions in the GraphQL API.

[options="header",cols="2m,5a"]
|===
| Name | Description
{{- range .Subscriptions }}
| {{.Name}} | {{.Description}}{{if .Changelog}}
{{.Changelog}}{{end}}
{{- end }}
|===
{{- else }}

[NOTE]
====
No subscriptions exist in this schema.
====
{{- end }}

`
		templateParts = append(templateParts, subscriptionSection)
	}

	// Combine all enabled sections
	catalogueBody := strings.Join(templateParts, "")

	tmpl, err := template.New("catalogue-body").Parse(catalogueBody)
	if err != nil {
		return fmt.Errorf("error parsing catalogue body template: %v", err)
	}

	err = tmpl.Execute(g.writer, data)
	if err != nil {
		return fmt.Errorf("error executing catalogue body template: %v", err)
	}

	return nil
}

// generateCatalogue generates the complete catalogue document (catalogue mode)
func (g *Generator) generateCatalogue() error {
	data := g.collectCatalogueData()

	tmpl, err := template.New("catalogue").Parse(templates.CatalogueTemplate)
	if err != nil {
		return fmt.Errorf("error parsing catalogue template: %v", err)
	}

	err = tmpl.Execute(g.writer, data)
	if err != nil {
		return fmt.Errorf("error executing catalogue template: %v", err)
	}

	if g.config.Verbose {
		fmt.Fprintf(os.Stderr, "Generated catalogue with %d queries, %d mutations, and %d subscriptions\n",
			len(data.Queries), len(data.Mutations), len(data.Subscriptions))
	}

	return nil
}

// groupMutationsByType groups mutations by their naming prefix (add, update, delete, save, general)
func groupMutationsByType(mutations []CatalogueEntry) []MutationGroup {
	// Define the order of groups
	groupOrder := []string{"Adds", "Updates", "Deletes", "Saves", "General"}

	// Map to hold mutations by group
	groupMap := make(map[string][]CatalogueEntry)

	for _, mutation := range mutations {
		groupName := getMutationGroupName(mutation.Name)
		groupMap[groupName] = append(groupMap[groupName], mutation)
	}

	// Build the result in the defined order, only including groups that have mutations
	var result []MutationGroup
	for _, groupName := range groupOrder {
		if mutations, exists := groupMap[groupName]; exists && len(mutations) > 0 {
			result = append(result, MutationGroup{
				GroupName: groupName,
				Mutations: mutations,
			})
		}
	}

	return result
}

// getMutationGroupName determines the group name based on mutation name prefix
func getMutationGroupName(mutationName string) string {
	lowerName := strings.ToLower(mutationName)

	if strings.HasPrefix(lowerName, "add") {
		return "Adds"
	}
	if strings.HasPrefix(lowerName, "update") {
		return "Updates"
	}
	if strings.HasPrefix(lowerName, "delete") {
		return "Deletes"
	}
	if strings.HasPrefix(lowerName, "save") {
		return "Saves"
	}

	return "General"
}
