package generator

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/vektah/gqlparser/v2/ast"

	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/changelog"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/config"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/parser"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/templates"
)

// Generator handles AsciiDoc generation from GraphQL schemas
type Generator struct {
	config *config.Config
	schema *ast.Schema
	writer io.Writer
}

// New creates a new Generator instance
func New(cfg *config.Config, schema *ast.Schema, writer io.Writer) *Generator {
	return &Generator{
		config: cfg,
		schema: schema,
		writer: writer,
	}
}

// Generate generates the complete AsciiDoc documentation
func (g *Generator) Generate() error {
	// Print header
	g.printHeader()

	// Create definitions map for type processing
	definitionsMap := make(map[string]*ast.Definition)
	for _, def := range g.schema.Types {
		definitionsMap[def.Name] = def
	}

	// Sort definitions
	sortedDefs := make([]*ast.Definition, 0, len(g.schema.Types))
	for _, def := range g.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	sort.Slice(sortedDefs, func(i, j int) bool {
		return sortedDefs[i].Name < sortedDefs[j].Name
	})

	// Generate sections based on configuration
	if g.config.IncludeQueries && g.schema.Query != nil {
		g.generateQueries(definitionsMap)
	}

	if g.config.IncludeMutations && g.schema.Mutation != nil {
		g.generateMutations(definitionsMap)
	}

	if g.config.IncludeSubscriptions && g.schema.Subscription != nil {
		g.generateSubscriptions(definitionsMap)
	}

	if g.config.IncludeTypes {
		g.generateTypes(sortedDefs, definitionsMap)
	}

	if g.config.IncludeEnums {
		g.generateEnums(sortedDefs, definitionsMap)
	}

	if g.config.IncludeInputs {
		g.generateInputs(sortedDefs, definitionsMap)
	}

	if g.config.IncludeDirectives {
		g.generateDirectives(sortedDefs)
	}

	if g.config.IncludeScalars {
		g.generateScalars(sortedDefs)
	}

	return nil
}

// printHeader prints the AsciiDoc document header
func (g *Generator) printHeader() {
	fmt.Fprintln(g.writer, "= GraphQL Documentation")
	fmt.Fprintln(g.writer, ":toc: left")
	fmt.Fprintf(g.writer, ":revdate: %s\n", time.Now().Format("Mon, 02 Jan 2006 15:04:05 MST"))
	fmt.Fprintf(g.writer, ":commandline: %s\n", strings.Join(os.Args, " "))
	fmt.Fprintf(g.writer, ":sourceFile: %s\n", g.config.SchemaFile)
	fmt.Fprintln(g.writer, ":reproducible:")
	fmt.Fprintln(g.writer, ":page-partial:")
	fmt.Fprintln(g.writer, ":sect-anchors:")
	fmt.Fprintln(g.writer, ":table-caption!:")
	fmt.Fprintln(g.writer, ":table-stripes: even")
	fmt.Fprintln(g.writer, ":pdf-page-size: A4")
	fmt.Fprintln(g.writer, ":tags: api, GraphQL, nodes, types, query")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[IMPORTANT]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintf(g.writer, "This is automatically generated from the schema file `%s`. +\n", g.config.SchemaFile)
	fmt.Fprintln(g.writer, "Do not edit this file directly. +")
	fmt.Fprintln(g.writer, "Last generated _{revdate}_")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

// generateQueries generates the queries section
func (g *Generator) generateQueries(definitionsMap map[string]*ast.Definition) {
	if g.schema.Query == nil {
		return
	}

	fmt.Fprintln(g.writer, "== Query")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)
	if g.schema.Query.Description != "" {
		fmt.Fprintln(g.writer, parser.ProcessDescription(g.schema.Query.Description))
	}

	for _, f := range g.schema.Query.Fields {
		// Skip internal queries if configured
		if g.config.ExcludeInternal && strings.Contains(f.Description, "INTERNAL") {
			continue
		}

		g.generateQueryField(f, definitionsMap)
	}
}

// generateQueryField generates a single query field
func (g *Generator) generateQueryField(field *ast.FieldDefinition, definitionsMap map[string]*ast.Definition) {
	fmt.Fprintf(g.writer, "// tag::query-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintf(g.writer, "[[query_%s]]\n", strings.ToLower(field.Name))
	fmt.Fprintf(g.writer, "=== %s\n", field.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)

	// Process description and extract changelog
	processedDesc, changelog := changelog.ProcessWithChangelog(field.Description, parser.ProcessDescription)

	fmt.Fprintf(g.writer, "// tag::method-description-%s[]\n", field.Name)
	if processedDesc != "" {
		fmt.Fprintln(g.writer, processedDesc)
	}
	fmt.Fprintf(g.writer, "// end::method-description-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	// Generate method signature
	fmt.Fprintf(g.writer, "// tag::method-signature-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, ".query: %s\n", field.Name)
	fmt.Fprintln(g.writer, "[source, kotlin]")
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "%s(\n", field.Name)

	// Generate arguments
	for i, arg := range field.Arguments {
		argType := parser.ProcessTypeName(arg.Type.String(), definitionsMap)
		fmt.Fprintf(g.writer, "  %s: %s", arg.Name, argType)
		if i < len(field.Arguments)-1 {
			fmt.Fprint(g.writer, " ,")
		}
		fmt.Fprintf(g.writer, " <%d> \n", i+1)
	}

	fmt.Fprintf(g.writer, "): %s <%d>\n", parser.ProcessTypeName(field.Type.String(), definitionsMap), len(field.Arguments)+1)
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "// end::method-signature-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	// Add other sections...
	fmt.Fprintf(g.writer, "// tag::method-args-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "// end::method-args-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	fmt.Fprintf(g.writer, "// tag::query-name-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "*Query Name:* _%s_\n", field.Name)
	fmt.Fprintf(g.writer, "// end::query-name-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	fmt.Fprintf(g.writer, "// tag::query-return-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "*Return:* %s\n", parser.ProcessTypeName(field.Type.String(), definitionsMap))
	fmt.Fprintf(g.writer, "// end::query-return-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	if len(field.Arguments) > 0 {
		fmt.Fprintf(g.writer, "// tag::arguments-%s[]\n", field.Name)
		fmt.Fprintln(g.writer, ".Arguments")
		for _, arg := range field.Arguments {
			fmt.Fprintf(g.writer, "* `%s : %s`\n", arg.Name, arg.Type.String())
		}
		fmt.Fprintf(g.writer, "// end::arguments-%s[]\n", field.Name)
		fmt.Fprintln(g.writer)
	}

	// Add changelog section
	if changelog != "" {
		fmt.Fprintf(g.writer, "// tag::query-changelog-%s[]\n", field.Name)
		fmt.Fprint(g.writer, changelog)
		fmt.Fprintf(g.writer, "// end::query-changelog-%s[]\n", field.Name)
		fmt.Fprintln(g.writer)
	}

	fmt.Fprintf(g.writer, "// end::query-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)
}

// Placeholder implementations for other generators
func (g *Generator) generateMutations(definitionsMap map[string]*ast.Definition) {
	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Mutations")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Mutations section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

func (g *Generator) generateSubscriptions(definitionsMap map[string]*ast.Definition) {
	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Subscriptions")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Subscriptions section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

func (g *Generator) generateTypes(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) {
	var typeInfos []TypeInfo

	for _, t := range sortedDefs {
		if t.Kind == ast.Object && !isBuiltInType(t.Name) {
			// Generate fields table
			fieldsTableString, err := g.getTypeFieldsTableString(t, definitionsMap)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error generating fields table for type %s: %v\n", t.Name, err)
				fieldsTableString = "[ERROR generating fields table]"
			}

			// Process type description and extract changelog
			processedDesc, changelog := changelog.ProcessWithChangelog(t.Description, parser.ProcessDescription)

			typeInfo := TypeInfo{
				Name:        t.Name,
				Kind:        string(t.Kind),
				AnchorName:  "type_" + parser.CamelToSnake(t.Name),
				Description: processedDesc,
				FieldsTable: fieldsTableString,
				IsInterface: t.Kind == ast.Interface,
				Changelog:   changelog,
			}
			typeInfos = append(typeInfos, typeInfo)
		}
	}

	if len(typeInfos) > 0 {
		data := struct {
			TypesTag string
			Types    []TypeInfo
		}{
			TypesTag: "== Types",
			Types:    typeInfos,
		}

		tmpl, err := template.New("types").Funcs(template.FuncMap{
			"printAsciiDocTagsTmpl": func(s string) string { return s },
		}).Parse(templates.TypeSectionTemplate)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing type section template: %v\n", err)
			return
		}

		err = tmpl.Execute(g.writer, data)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error executing type section template: %v\n", err)
		}
	}
}

func (g *Generator) generateEnums(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) {
	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Enums")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Enums section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

func (g *Generator) generateInputs(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) {
	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Inputs")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Inputs section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

func (g *Generator) generateDirectives(sortedDefs []*ast.Definition) {
	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Directives")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Directives section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

func (g *Generator) generateScalars(sortedDefs []*ast.Definition) {
	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Scalars")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Scalars section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

// Helper functions
func (g *Generator) getTypeFieldsTableString(t *ast.Definition, definitionsMap map[string]*ast.Definition) (string, error) {
	var builder strings.Builder

	builder.WriteString(".type: " + t.Name + "\n")
	builder.WriteString("[options=\"header\"]\n")
	builder.WriteString("|===\n")
	builder.WriteString("| Type | Field | Description \n")

	for _, f := range t.Fields {
		typeName := parser.ProcessTypeName(f.Type.String(), definitionsMap)
		processedDesc, changelog := changelog.ProcessWithChangelog(f.Description, parser.ProcessDescription)

		data := FieldData{
			Type:            typeName,
			Name:            f.Name,
			Description:     processedDesc,
			RequiredOrArray: strings.Contains(typeName, "!") || strings.Contains(typeName, "["),
			Changelog:       changelog,
		}

		tmpl, err := template.New("field").Funcs(template.FuncMap{
			"processDescription": parser.ProcessDescription,
		}).Parse(templates.FieldTemplate)
		if err != nil {
			return "", err
		}

		err = tmpl.Execute(&builder, data)
		if err != nil {
			return "", err
		}
	}

	builder.WriteString("|===\n")
	return builder.String(), nil
}

func isBuiltInType(typeName string) bool {
	builtInTypes := map[string]bool{
		"String":  true,
		"Int":     true,
		"Float":   true,
		"Boolean": true,
		"ID":      true,
		"Query":   true,
		"Mutation": true,
		"Subscription": true,
	}
	return builtInTypes[typeName]
}