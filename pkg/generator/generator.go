package generator

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/vektah/gqlparser/v2/ast"

	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/changelog"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/config"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/metrics"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/parser"
	"github.com/bovinemagnet/graphqls-to-asciidoc/pkg/templates"
)

// Generator handles AsciiDoc generation from GraphQL schemas
type Generator struct {
	config  *config.Config
	schema  *ast.Schema
	writer  io.Writer
	metrics *metrics.Metrics
}

// New creates a new Generator instance
func New(cfg *config.Config, schema *ast.Schema, writer io.Writer) *Generator {
	return &Generator{
		config:  cfg,
		schema:  schema,
		writer:  writer,
		metrics: metrics.New(cfg),
	}
}

// Generate generates the complete AsciiDoc documentation
func (g *Generator) Generate() error {
	// Log input parameters
	g.metrics.LogInputParameters()

	// Print header
	headerTimer := g.metrics.StartSection("Header")
	g.printHeader()
	headerTimer.AddCount(1)
	headerTimer.Finish()

	// Create definitions map for type processing
	g.metrics.LogProgress("Setup", "Creating definitions map")
	definitionsMap := make(map[string]*ast.Definition)
	for _, def := range g.schema.Types {
		definitionsMap[def.Name] = def
	}

	// Sort definitions
	sortedDefs := make([]*ast.Definition, 0, len(g.schema.Types))
	for _, def := range g.schema.Types {
		sortedDefs = append(sortedDefs, def)
	}
	sort.Slice(sortedDefs, func(i, j int) bool {
		return sortedDefs[i].Name < sortedDefs[j].Name
	})

	g.metrics.LogProgress("Setup", fmt.Sprintf("Found %d total definitions", len(g.schema.Types)))

	// Generate sections based on configuration
	if g.config.IncludeQueries && g.schema.Query != nil {
		timer := g.metrics.StartSection("Queries")
		count := g.generateQueries(definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeMutations && g.schema.Mutation != nil {
		timer := g.metrics.StartSection("Mutations")
		count := g.generateMutations(definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeSubscriptions && g.schema.Subscription != nil {
		timer := g.metrics.StartSection("Subscriptions")
		count := g.generateSubscriptions(definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeTypes {
		timer := g.metrics.StartSection("Types")
		count := g.generateTypes(sortedDefs, definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeEnums {
		timer := g.metrics.StartSection("Enums")
		count := g.generateEnums(sortedDefs, definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeInputs {
		timer := g.metrics.StartSection("Inputs")
		count := g.generateInputs(sortedDefs, definitionsMap)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeDirectives {
		timer := g.metrics.StartSection("Directives")
		count := g.generateDirectives(sortedDefs)
		timer.AddCount(count)
		timer.Finish()
	}

	if g.config.IncludeScalars {
		timer := g.metrics.StartSection("Scalars")
		count := g.generateScalars(sortedDefs)
		timer.AddCount(count)
		timer.Finish()
	}

	// Log final metrics table
	g.metrics.LogMetricsTable()

	return nil
}

// printHeader prints the AsciiDoc document header
func (g *Generator) printHeader() {
	fmt.Fprintln(g.writer, "= GraphQL Documentation")
	fmt.Fprintln(g.writer, ":toc: left")
	fmt.Fprintf(g.writer, ":revdate: %s\n", time.Now().Format("Mon, 02 Jan 2006 15:04:05 MST"))
	fmt.Fprintf(g.writer, ":commandline: %s\n", strings.Join(os.Args, " "))
	fmt.Fprintf(g.writer, ":sourceFile: %s\n", g.config.SchemaFile)
	fmt.Fprintln(g.writer, ":reproducible:")
	fmt.Fprintln(g.writer, ":page-partial:")
	fmt.Fprintln(g.writer, ":sect-anchors:")
	fmt.Fprintln(g.writer, ":table-caption!:")
	fmt.Fprintln(g.writer, ":table-stripes: even")
	fmt.Fprintln(g.writer, ":pdf-page-size: A4")
	fmt.Fprintln(g.writer, ":tags: api, GraphQL, nodes, types, query")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[IMPORTANT]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintf(g.writer, "This is automatically generated from the schema file `%s`. +\n", g.config.SchemaFile)
	fmt.Fprintln(g.writer, "Do not edit this file directly. +")
	fmt.Fprintln(g.writer, "Last generated _{revdate}_")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)
}

// generateQueries generates the queries section
func (g *Generator) generateQueries(definitionsMap map[string]*ast.Definition) int {
	if g.schema.Query == nil {
		return 0
	}

	g.metrics.LogProgress("Queries", "Starting query generation")

	fmt.Fprintln(g.writer, "== Query")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)
	if g.schema.Query.Description != "" {
		fmt.Fprintln(g.writer, parser.ProcessDescription(g.schema.Query.Description))
	}

	count := 0
	for _, f := range g.schema.Query.Fields {
		// Skip internal queries if configured
		if g.config.ExcludeInternal && strings.Contains(f.Description, "INTERNAL") {
			continue
		}

		g.generateQueryField(f, definitionsMap)
		count++
	}

	g.metrics.LogProgress("Queries", fmt.Sprintf("Generated %d queries", count))
	return count
}

// generateQueryField generates a single query field
func (g *Generator) generateQueryField(field *ast.FieldDefinition, definitionsMap map[string]*ast.Definition) {
	fmt.Fprintf(g.writer, "// tag::query-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintf(g.writer, "[[query_%s]]\n", strings.ToLower(field.Name))
	fmt.Fprintf(g.writer, "=== %s\n", field.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer)

	// Process description and extract changelog
	processedDesc, changelog := changelog.ProcessWithChangelog(field.Description, parser.ProcessDescription)

	fmt.Fprintf(g.writer, "// tag::method-description-%s[]\n", field.Name)
	if processedDesc != "" {
		fmt.Fprintln(g.writer, processedDesc)
	}
	fmt.Fprintf(g.writer, "// end::method-description-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	// Generate method signature
	fmt.Fprintf(g.writer, "// tag::method-signature-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, ".query: %s\n", field.Name)
	fmt.Fprintln(g.writer, "[source, kotlin]")
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "%s(\n", field.Name)

	// Generate arguments
	for i, arg := range field.Arguments {
		argType := parser.ProcessTypeName(arg.Type.String(), definitionsMap)
		fmt.Fprintf(g.writer, "  %s: %s", arg.Name, argType)
		if i < len(field.Arguments)-1 {
			fmt.Fprint(g.writer, " ,")
		}
		fmt.Fprintf(g.writer, " <%d> \n", i+1)
	}

	fmt.Fprintf(g.writer, "): %s <%d>\n", parser.ProcessTypeName(field.Type.String(), definitionsMap), len(field.Arguments)+1)
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "// end::method-signature-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	// Add other sections...
	fmt.Fprintf(g.writer, "// tag::method-args-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "// end::method-args-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	fmt.Fprintf(g.writer, "// tag::query-name-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "*Query Name:* _%s_\n", field.Name)
	fmt.Fprintf(g.writer, "// end::query-name-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	fmt.Fprintf(g.writer, "// tag::query-return-%s[]\n", field.Name)
	fmt.Fprintf(g.writer, "*Return:* %s\n", parser.ProcessTypeName(field.Type.String(), definitionsMap))
	fmt.Fprintf(g.writer, "// end::query-return-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)

	if len(field.Arguments) > 0 {
		fmt.Fprintf(g.writer, "// tag::arguments-%s[]\n", field.Name)
		fmt.Fprintln(g.writer, ".Arguments")
		for _, arg := range field.Arguments {
			fmt.Fprintf(g.writer, "* `%s : %s`\n", arg.Name, arg.Type.String())
		}
		fmt.Fprintf(g.writer, "// end::arguments-%s[]\n", field.Name)
		fmt.Fprintln(g.writer)
	}

	// Add changelog section
	if changelog != "" {
		fmt.Fprintf(g.writer, "// tag::query-changelog-%s[]\n", field.Name)
		fmt.Fprint(g.writer, changelog)
		fmt.Fprintf(g.writer, "// end::query-changelog-%s[]\n", field.Name)
		fmt.Fprintln(g.writer)
	}

	fmt.Fprintf(g.writer, "// end::query-%s[]\n", field.Name)
	fmt.Fprintln(g.writer)
}

// Placeholder implementations for other generators
func (g *Generator) generateMutations(definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Mutations", "Starting mutations generation")

	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Mutations")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Mutations section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)

	count := 0 // No actual mutations processed yet
	g.metrics.LogProgress("Mutations", fmt.Sprintf("Generated %d mutations", count))
	return count
}

func (g *Generator) generateSubscriptions(definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Subscriptions", "Starting subscriptions generation")

	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Subscriptions")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Subscriptions section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)

	count := 0 // No actual subscriptions processed yet
	g.metrics.LogProgress("Subscriptions", fmt.Sprintf("Generated %d subscriptions", count))
	return count
}

func (g *Generator) generateTypes(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Types", "Starting types generation")

	var typeInfos []TypeInfo
	count := 0

	for _, t := range sortedDefs {
		if t.Kind == ast.Object && !isBuiltInType(t.Name) {
			// Generate fields table
			fieldsTableString, err := g.getTypeFieldsTableString(t, definitionsMap)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error generating fields table for type %s: %v\n", t.Name, err)
				fieldsTableString = "[ERROR generating fields table]"
			}

			// Process type description and extract changelog
			processedDesc, changelog := changelog.ProcessWithChangelog(t.Description, parser.ProcessDescription)

			typeInfo := TypeInfo{
				Name:        t.Name,
				Kind:        string(t.Kind),
				AnchorName:  "type_" + parser.CamelToSnake(t.Name),
				Description: processedDesc,
				FieldsTable: fieldsTableString,
				IsInterface: t.Kind == ast.Interface,
				Changelog:   changelog,
			}
			typeInfos = append(typeInfos, typeInfo)
			count++
		}
	}

	if len(typeInfos) > 0 {
		data := struct {
			TypesTag string
			Types    []TypeInfo
		}{
			TypesTag: "== Types",
			Types:    typeInfos,
		}

		tmpl, err := template.New("types").Funcs(template.FuncMap{
			"printAsciiDocTagsTmpl": func(s string) string { return s },
		}).Parse(templates.TypeSectionTemplate)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing type section template: %v\n", err)
			g.metrics.LogProgress("Types", fmt.Sprintf("Generated %d types", count))
			return count
		}

		err = tmpl.Execute(g.writer, data)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error executing type section template: %v\n", err)
		}
	}

	g.metrics.LogProgress("Types", fmt.Sprintf("Generated %d types", count))
	return count
}

func (g *Generator) generateEnums(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Enums", "Starting enums generation")

	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Enums")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Enums section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)

	count := 0 // No actual enums processed yet
	g.metrics.LogProgress("Enums", fmt.Sprintf("Generated %d enums", count))
	return count
}

func (g *Generator) generateInputs(sortedDefs []*ast.Definition, definitionsMap map[string]*ast.Definition) int {
	g.metrics.LogProgress("Inputs", "Starting inputs generation")

	// Implementation would go here - simplified for now
	fmt.Fprintln(g.writer, "== Inputs")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "[NOTE]")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer, "Inputs section - implementation in progress")
	fmt.Fprintln(g.writer, "====")
	fmt.Fprintln(g.writer)

	count := 0 // No actual inputs processed yet
	g.metrics.LogProgress("Inputs", fmt.Sprintf("Generated %d inputs", count))
	return count
}

func (g *Generator) generateDirectives(sortedDefs []*ast.Definition) int {
	g.metrics.LogProgress("Directives", "Starting directives generation")

	if len(g.schema.Directives) == 0 {
		g.metrics.LogProgress("Directives", "No directives found")
		return 0
	}

	fmt.Fprintln(g.writer, "== Directives")
	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "// tag::DIRECTIVES[]")
	fmt.Fprintln(g.writer)

	// Sort directives by name for consistent output
	var directiveNames []string
	for name := range g.schema.Directives {
		directiveNames = append(directiveNames, name)
	}
	sort.Strings(directiveNames)

	count := 0
	for _, name := range directiveNames {
		directive := g.schema.Directives[name]
		g.generateDirective(directive)
		count++
	}

	fmt.Fprintln(g.writer, "// end::DIRECTIVES[]")

	g.metrics.LogProgress("Directives", fmt.Sprintf("Generated %d directives", count))
	return count
}

// generateDirective generates documentation for a single directive
func (g *Generator) generateDirective(directive *ast.DirectiveDefinition) {
	fmt.Fprintf(g.writer, "// tag::directive-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer)
	fmt.Fprintf(g.writer, "[[directive_%s]]\n", strings.ToLower(directive.Name))
	fmt.Fprintf(g.writer, "=== @%s\n", directive.Name)
	fmt.Fprintln(g.writer)

	// Process description
	if directive.Description != "" {
		processedDesc := parser.ProcessDescription(directive.Description)
		fmt.Fprintf(g.writer, "// tag::directive-description-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer, processedDesc)
		fmt.Fprintf(g.writer, "// end::directive-description-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	// Generate directive signature
	fmt.Fprintf(g.writer, "// tag::directive-signature-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer, ".Directive Signature")
	fmt.Fprintln(g.writer, "[source, graphql]")
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "directive @%s", directive.Name)

	if len(directive.Arguments) > 0 {
		fmt.Fprint(g.writer, "(")
		for i, arg := range directive.Arguments {
			if i > 0 {
				fmt.Fprint(g.writer, ", ")
			}
			fmt.Fprintf(g.writer, "%s: %s", arg.Name, arg.Type.String())
			if arg.DefaultValue != nil {
				fmt.Fprintf(g.writer, " = %s", arg.DefaultValue.String())
			}
		}
		fmt.Fprint(g.writer, ")")
	}

	if len(directive.Locations) > 0 {
		fmt.Fprint(g.writer, " on ")
		for i, location := range directive.Locations {
			if i > 0 {
				fmt.Fprint(g.writer, " | ")
			}
			fmt.Fprint(g.writer, string(location))
		}
	}

	fmt.Fprintln(g.writer)
	fmt.Fprintln(g.writer, "----")
	fmt.Fprintf(g.writer, "// end::directive-signature-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer)

	// Generate arguments table if there are arguments
	if len(directive.Arguments) > 0 {
		fmt.Fprintf(g.writer, "// tag::directive-arguments-%s[]\n", directive.Name)
		fmt.Fprintf(g.writer, ".@%s Arguments\n", directive.Name)
		fmt.Fprintln(g.writer, "[options=\"header\",stripes=\"even\"]")
		fmt.Fprintln(g.writer, "|===")
		fmt.Fprintln(g.writer, "| Argument | Type | Default | Description")

		for _, arg := range directive.Arguments {
			fmt.Fprintf(g.writer, "| `%s`", arg.Name)
			fmt.Fprintf(g.writer, " | `%s`", arg.Type.String())

			// Default value
			if arg.DefaultValue != nil {
				fmt.Fprintf(g.writer, " | `%s`", arg.DefaultValue.String())
			} else {
				fmt.Fprint(g.writer, " | _none_")
			}

			// Description
			if arg.Description != "" {
				processedDesc := parser.ProcessDescription(arg.Description)
				fmt.Fprintf(g.writer, " | %s", processedDesc)
			} else {
				fmt.Fprint(g.writer, " | _No description_")
			}
			fmt.Fprintln(g.writer)
		}

		fmt.Fprintln(g.writer, "|===")
		fmt.Fprintf(g.writer, "// end::directive-arguments-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	// Generate locations information
	if len(directive.Locations) > 0 {
		fmt.Fprintf(g.writer, "// tag::directive-locations-%s[]\n", directive.Name)
		fmt.Fprintf(g.writer, ".@%s Usage Locations\n", directive.Name)
		for _, location := range directive.Locations {
			fmt.Fprintf(g.writer, "* `%s`\n", string(location))
		}
		fmt.Fprintf(g.writer, "// end::directive-locations-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	// Repeatable information
	if directive.IsRepeatable {
		fmt.Fprintf(g.writer, "// tag::directive-repeatable-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer, "NOTE: This directive is repeatable and can be used multiple times on the same element.")
		fmt.Fprintf(g.writer, "// end::directive-repeatable-%s[]\n", directive.Name)
		fmt.Fprintln(g.writer)
	}

	fmt.Fprintf(g.writer, "// end::directive-%s[]\n", directive.Name)
	fmt.Fprintln(g.writer)
}

func (g *Generator) generateScalars(sortedDefs []*ast.Definition) int {
	g.metrics.LogProgress("Scalars", "Starting scalars generation")

	var scalarInfos []ScalarInfo
	count := 0

	// Filter for scalar definitions and exclude built-in scalars
	for _, def := range sortedDefs {
		if def.Kind == ast.Scalar && !isBuiltInScalar(def.Name) {
			// Process description and extract changelog
			processedDesc, _ := changelog.ProcessWithChangelog(def.Description, parser.ProcessDescription)

			scalarInfo := ScalarInfo{
				Name:        def.Name,
				Description: processedDesc,
			}
			scalarInfos = append(scalarInfos, scalarInfo)
			count++
		}
	}

	// Prepare data for template
	data := ScalarData{
		ScalarTag:    "== Scalars",
		FoundScalars: len(scalarInfos) > 0,
		Scalars:      scalarInfos,
	}

	// Execute template
	tmpl, err := template.New("scalars").Funcs(template.FuncMap{
		"printAsciiDocTagsTmpl": func(s string) string { return s },
	}).Parse(templates.ScalarTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing scalar template: %v\n", err)
		g.metrics.LogProgress("Scalars", fmt.Sprintf("Generated %d scalars", count))
		return count
	}

	err = tmpl.Execute(g.writer, data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing scalar template: %v\n", err)
	}

	g.metrics.LogProgress("Scalars", fmt.Sprintf("Generated %d scalars", count))
	return count
}

// Helper functions
func (g *Generator) getTypeFieldsTableString(t *ast.Definition, definitionsMap map[string]*ast.Definition) (string, error) {
	var builder strings.Builder

	builder.WriteString(".type: " + t.Name + "\n")
	builder.WriteString("[options=\"header\"]\n")
	builder.WriteString("|===\n")
	builder.WriteString("| Type | Field | Description \n")

	for _, f := range t.Fields {
		typeName := parser.ProcessTypeName(f.Type.String(), definitionsMap)
		processedDesc, changelog := changelog.ProcessWithChangelog(f.Description, parser.ProcessDescription)

		data := FieldData{
			Type:            typeName,
			Name:            f.Name,
			Description:     processedDesc,
			RequiredOrArray: strings.Contains(typeName, "!") || strings.Contains(typeName, "["),
			Changelog:       changelog,
		}

		tmpl, err := template.New("field").Funcs(template.FuncMap{
			"processDescription": parser.ProcessDescription,
		}).Parse(templates.FieldTemplate)
		if err != nil {
			return "", err
		}

		err = tmpl.Execute(&builder, data)
		if err != nil {
			return "", err
		}
	}

	builder.WriteString("|===\n")
	return builder.String(), nil
}

func isBuiltInType(typeName string) bool {
	builtInTypes := map[string]bool{
		"String":       true,
		"Int":          true,
		"Float":        true,
		"Boolean":      true,
		"ID":           true,
		"Query":        true,
		"Mutation":     true,
		"Subscription": true,
	}
	return builtInTypes[typeName]
}

func isBuiltInScalar(typeName string) bool {
	builtInScalars := map[string]bool{
		"String":  true,
		"Int":     true,
		"Float":   true,
		"Boolean": true,
		"ID":      true,
	}
	return builtInScalars[typeName]
}
