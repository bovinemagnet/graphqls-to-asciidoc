= GraphQL Documentation
:toc: left
:revdate: Sat, 21 Jun 2025 13:30:28 AEST
:commandline: ./graphqls-to-asciidoc -s test/schema.graphql -o test/schema.adoc --verbose --subscriptions
:sourceFile: test/schema.graphql
:reproducible:
:page-partial:
:sect-anchors:
:table-caption!:
:table-stripes: even
:pdf-page-size: A4
:tags: api, GraphQL, nodes, types, query


[IMPORTANT]
====
This is automatically generated from the schema file `test/schema.graphql`. +
Do not edit this file directly. +
Last generated _{revdate}_
====

== Query


The root query
// tag::query-Tweet[]

[[query_tweet]]
=== Tweet


// tag::method-description-Tweet[]
[[get-tweet]]
Get a tweet by its ID

This is the primary method for retrieving individual tweets.
For bulk operations, see <<get-tweets>>.

.Arguments:
* `id`: the id of the tweet to search by.
// end::method-description-Tweet[]

// tag::method-signature-Tweet[]
.query: Tweet
[source, kotlin]
----
Tweet(
  id: `ID!` <1> 
): <<Tweet,`Tweet`>> <2>
----
// end::method-signature-Tweet[]

// tag::method-args-Tweet[]
// end::method-args-Tweet[]

// tag::query-name-Tweet[]
*Query Name:* _Tweet_
// end::query-name-Tweet[]

// tag::query-return-Tweet[]
*Return:* <<Tweet,`Tweet`>>
// end::query-return-Tweet[]

// tag::arguments-Tweet[]
.Arguments
* `id : ID!`
// end::arguments-Tweet[]

// end::query-Tweet[]

// tag::query-Tweets[]

[[query_tweets]]
=== Tweets


// tag::method-description-Tweets[]
[[get-tweets]]
Get a list of tweets, remember that it is `2024-01-08` for testing dates in the conversion.

**Performance notes:**
* Use pagination with `limit` and `skip` parameters
* For single tweet access, use <<get-tweet,the Tweet query>>
* See <<tweets-meta>> for metadata about the collection
// end::method-description-Tweets[]

// tag::method-signature-Tweets[]
.query: Tweets
[source, kotlin]
----
Tweets(
  limit: `Int!` , <1> 
  skip: `Int` , <2> 
  sort_field: `String` , <3> 
  sort_order: `String` <4> 
): [<<Tweet,`Tweet`>>] <5>
----
// end::method-signature-Tweets[]

// tag::method-args-Tweets[]
// end::method-args-Tweets[]

// tag::query-name-Tweets[]
*Query Name:* _Tweets_
// end::query-name-Tweets[]

// tag::query-return-Tweets[]
*Return:* [<<Tweet,`Tweet`>>]
// end::query-return-Tweets[]

// tag::arguments-Tweets[]
.Arguments
* `limit : Int!`
* `skip : Int`
* `sort_field : String`
* `sort_order : String`
// end::arguments-Tweets[]

// end::query-Tweets[]

// tag::query-TweetsMeta[]

[[query_tweetsmeta]]
=== TweetsMeta


// tag::method-description-TweetsMeta[]
[[tweets-meta]]
Get meta information about the list of tweets. This tests the list to query options.

This provides pagination and sorting metadata for <<get-tweets,the Tweets query>>.

* `limit`:  the max numer; _Required_
* `skip`: how many to skip
* `sort_field`: what to sort on
* `sort_order`: which direction to do you want to sort.
* _RETURNS_: an array of `Tweet`.
// end::method-description-TweetsMeta[]

// tag::method-signature-TweetsMeta[]
.query: TweetsMeta
[source, kotlin]
----
TweetsMeta(
): <<Meta,`Meta`>> <1>
----
// end::method-signature-TweetsMeta[]

// tag::method-args-TweetsMeta[]
// end::method-args-TweetsMeta[]

// tag::query-name-TweetsMeta[]
*Query Name:* _TweetsMeta_
// end::query-name-TweetsMeta[]

// tag::query-return-TweetsMeta[]
*Return:* <<Meta,`Meta`>>
// end::query-return-TweetsMeta[]

// end::query-TweetsMeta[]

// tag::query-User[]

[[query_user]]
=== User


// tag::method-description-User[]
Get a user by its ID
// end::method-description-User[]

// tag::method-signature-User[]
.query: User
[source, kotlin]
----
User(
  id: `ID!` <1> 
): <<User,`User`>> <2>
----
// end::method-signature-User[]

// tag::method-args-User[]
// end::method-args-User[]

// tag::query-name-User[]
*Query Name:* _User_
// end::query-name-User[]

// tag::query-return-User[]
*Return:* <<User,`User`>>
// end::query-return-User[]

// tag::arguments-User[]
.Arguments
* `id : ID!`
// end::arguments-User[]

// end::query-User[]

// tag::query-Notifications[]

[[query_notifications]]
=== Notifications


// tag::method-description-Notifications[]
Get a list of users
// end::method-description-Notifications[]

// tag::method-signature-Notifications[]
.query: Notifications
[source, kotlin]
----
Notifications(
  limit: `Int` <1> 
): [<<Notification,`Notification`>>] <2>
----
// end::method-signature-Notifications[]

// tag::method-args-Notifications[]
// end::method-args-Notifications[]

// tag::query-name-Notifications[]
*Query Name:* _Notifications_
// end::query-name-Notifications[]

// tag::query-return-Notifications[]
*Return:* [<<Notification,`Notification`>>]
// end::query-return-Notifications[]

// tag::arguments-Notifications[]
.Arguments
* `limit : Int`
// end::arguments-Notifications[]

// end::query-Notifications[]

// tag::query-NotificationsMeta[]

[[query_notificationsmeta]]
=== NotificationsMeta


// tag::method-description-NotificationsMeta[]
Get meta information about the list of notifications
// end::method-description-NotificationsMeta[]

// tag::method-signature-NotificationsMeta[]
.query: NotificationsMeta
[source, kotlin]
----
NotificationsMeta(
): <<Meta,`Meta`>> <1>
----
// end::method-signature-NotificationsMeta[]

// tag::method-args-NotificationsMeta[]
// end::method-args-NotificationsMeta[]

// tag::query-name-NotificationsMeta[]
*Query Name:* _NotificationsMeta_
// end::query-name-NotificationsMeta[]

// tag::query-return-NotificationsMeta[]
*Return:* <<Meta,`Meta`>>
// end::query-return-NotificationsMeta[]

// end::query-NotificationsMeta[]

// tag::query-TweetSentiment[]

[[query_tweetsentiment]]
=== TweetSentiment


// tag::method-description-TweetSentiment[]
Get a tweet's sentiment by its ID
// end::method-description-TweetSentiment[]

// tag::method-signature-TweetSentiment[]
.query: TweetSentiment
[source, kotlin]
----
TweetSentiment(
  id: `ID!` <1> 
): <<Sentiment,`Sentiment`>> <2>
----
// end::method-signature-TweetSentiment[]

// tag::method-args-TweetSentiment[]
// end::method-args-TweetSentiment[]

// tag::query-name-TweetSentiment[]
*Query Name:* _TweetSentiment_
// end::query-name-TweetSentiment[]

// tag::query-return-TweetSentiment[]
*Return:* <<Sentiment,`Sentiment`>>
// end::query-return-TweetSentiment[]

// tag::arguments-TweetSentiment[]
.Arguments
* `id : ID!`
// end::arguments-TweetSentiment[]

// end::query-TweetSentiment[]

// tag::query-TweetSentiments1[]

[[query_tweetsentiments1]]
=== TweetSentiments1


// tag::method-description-TweetSentiments1[]
1: Get a tweet's sentiment by its IDs (plural)
// end::method-description-TweetSentiments1[]

// tag::method-signature-TweetSentiments1[]
.query: TweetSentiments1
[source, kotlin]
----
TweetSentiments1(
  id: [`ID`] <1> 
): [<<Sentiment,`Sentiment`>>] <2>
----
// end::method-signature-TweetSentiments1[]

// tag::method-args-TweetSentiments1[]
// end::method-args-TweetSentiments1[]

// tag::query-name-TweetSentiments1[]
*Query Name:* _TweetSentiments1_
// end::query-name-TweetSentiments1[]

// tag::query-return-TweetSentiments1[]
*Return:* [<<Sentiment,`Sentiment`>>]
// end::query-return-TweetSentiments1[]

// tag::arguments-TweetSentiments1[]
.Arguments
* `id : [ID]`
// end::arguments-TweetSentiments1[]

// end::query-TweetSentiments1[]

// tag::query-TweetSentiments2[]

[[query_tweetsentiments2]]
=== TweetSentiments2


// tag::method-description-TweetSentiments2[]
2: Get a tweet's sentiment by its IDs (plural)
// end::method-description-TweetSentiments2[]

// tag::method-signature-TweetSentiments2[]
.query: TweetSentiments2
[source, kotlin]
----
TweetSentiments2(
  id: [`ID!`] <1> 
): [<<Sentiment,`Sentiment`>>] <2>
----
// end::method-signature-TweetSentiments2[]

// tag::method-args-TweetSentiments2[]
// end::method-args-TweetSentiments2[]

// tag::query-name-TweetSentiments2[]
*Query Name:* _TweetSentiments2_
// end::query-name-TweetSentiments2[]

// tag::query-return-TweetSentiments2[]
*Return:* [<<Sentiment,`Sentiment`>>]
// end::query-return-TweetSentiments2[]

// tag::arguments-TweetSentiments2[]
.Arguments
* `id : [ID!]`
// end::arguments-TweetSentiments2[]

// end::query-TweetSentiments2[]

// tag::query-TweetSentiments3[]

[[query_tweetsentiments3]]
=== TweetSentiments3


// tag::method-description-TweetSentiments3[]
3: Get a tweet's sentiment by its IDs (plural)
// end::method-description-TweetSentiments3[]

// tag::method-signature-TweetSentiments3[]
.query: TweetSentiments3
[source, kotlin]
----
TweetSentiments3(
  id: [`ID`]! <1> 
): [<<Sentiment,`Sentiment`>>] <2>
----
// end::method-signature-TweetSentiments3[]

// tag::method-args-TweetSentiments3[]
// end::method-args-TweetSentiments3[]

// tag::query-name-TweetSentiments3[]
*Query Name:* _TweetSentiments3_
// end::query-name-TweetSentiments3[]

// tag::query-return-TweetSentiments3[]
*Return:* [<<Sentiment,`Sentiment`>>]
// end::query-return-TweetSentiments3[]

// tag::arguments-TweetSentiments3[]
.Arguments
* `id : [ID]!`
// end::arguments-TweetSentiments3[]

// end::query-TweetSentiments3[]

// tag::query-TweetSentiments4[]

[[query_tweetsentiments4]]
=== TweetSentiments4


// tag::method-description-TweetSentiments4[]
4: Get a tweet's sentiment by its IDs (plural)
// end::method-description-TweetSentiments4[]

// tag::method-signature-TweetSentiments4[]
.query: TweetSentiments4
[source, kotlin]
----
TweetSentiments4(
  id: [`ID!`]! <1> 
): [<<Sentiment,`Sentiment`>>] <2>
----
// end::method-signature-TweetSentiments4[]

// tag::method-args-TweetSentiments4[]
// end::method-args-TweetSentiments4[]

// tag::query-name-TweetSentiments4[]
*Query Name:* _TweetSentiments4_
// end::query-name-TweetSentiments4[]

// tag::query-return-TweetSentiments4[]
*Return:* [<<Sentiment,`Sentiment`>>]
// end::query-return-TweetSentiments4[]

// tag::arguments-TweetSentiments4[]
.Arguments
* `id : [ID!]!`
// end::arguments-TweetSentiments4[]

// end::query-TweetSentiments4[]

// tag::query-tweetSentiments5[]

[[query_tweetsentiments5]]
=== tweetSentiments5


// tag::method-description-tweetSentiments5[]
**INTERNAL**:

An example of an internal query.

* `id`: A list of id's that are _REQUIRED_
* _RETURNS_ :  a list of Sentiments
// end::method-description-tweetSentiments5[]

// tag::method-signature-tweetSentiments5[]
.query: tweetSentiments5
[source, kotlin]
----
tweetSentiments5(
  id: [`ID!`]! <1> 
): [<<Sentiment,`Sentiment`>>] <2>
----
// end::method-signature-tweetSentiments5[]

// tag::method-args-tweetSentiments5[]
// end::method-args-tweetSentiments5[]

// tag::query-name-tweetSentiments5[]
*Query Name:* _tweetSentiments5_
// end::query-name-tweetSentiments5[]

// tag::query-return-tweetSentiments5[]
*Return:* [<<Sentiment,`Sentiment`>>]
// end::query-return-tweetSentiments5[]

// tag::arguments-tweetSentiments5[]
.Arguments
* `id : [ID!]!`
// end::arguments-tweetSentiments5[]

// end::query-tweetSentiments5[]

// tag::query-tweetSentimentsDep[]

[[query_tweetsentimentsdep]]
=== tweetSentimentsDep


// tag::method-description-tweetSentimentsDep[]
**INTERNAL**: Simple endpoint to test it is functioning.

**PERMISSION**: PRIVATE-ONLY

An example of an internal query.
`@deprecated(reason: "Internal test")`
* `id`: A list of id's that are _REQUIRED_
* _RETURNS_ :  a list of Sentiments
// end::method-description-tweetSentimentsDep[]

// tag::method-signature-tweetSentimentsDep[]
.query: tweetSentimentsDep
[source, kotlin]
----
tweetSentimentsDep(
  id: [`ID!`]! <1> 
): [<<Sentiment,`Sentiment`>>] <2>
----
// end::method-signature-tweetSentimentsDep[]

// tag::method-args-tweetSentimentsDep[]
// end::method-args-tweetSentimentsDep[]

// tag::query-name-tweetSentimentsDep[]
*Query Name:* _tweetSentimentsDep_
// end::query-name-tweetSentimentsDep[]

// tag::query-return-tweetSentimentsDep[]
*Return:* [<<Sentiment,`Sentiment`>>]
// end::query-return-tweetSentimentsDep[]

// tag::arguments-tweetSentimentsDep[]
.Arguments
* `id : [ID!]!`
// end::arguments-tweetSentimentsDep[]

// end::query-tweetSentimentsDep[]

// tag::query-tweetSentimentCode[]

[[query_tweetsentimentcode]]
=== tweetSentimentCode


// tag::method-description-tweetSentimentCode[]
An example of an internal query with callouts.

[source,graphql]
----
query GetTweetSentiment {
  tweetSentimentCode(id: "123") { <1>
    sentiment <2>
    confidence <3>
  }
}
----

(1) Query the tweet sentiment endpoint with an ID
(2) Get the sentiment value
(3) Also retrieve confidence level

`@deprecated(reason: "Internal test")`
* `id`: An id that is _REQUIRED_
* _RETURNS_ :  a list of Sentiments
// end::method-description-tweetSentimentCode[]

// tag::method-signature-tweetSentimentCode[]
.query: tweetSentimentCode
[source, kotlin]
----
tweetSentimentCode(
  id: `ID!` <1> 
): <<Sentiment,`Sentiment`>> <2>
----
// end::method-signature-tweetSentimentCode[]

// tag::method-args-tweetSentimentCode[]
// end::method-args-tweetSentimentCode[]

// tag::query-name-tweetSentimentCode[]
*Query Name:* _tweetSentimentCode_
// end::query-name-tweetSentimentCode[]

// tag::query-return-tweetSentimentCode[]
*Return:* <<Sentiment,`Sentiment`>>
// end::query-return-tweetSentimentCode[]

// tag::arguments-tweetSentimentCode[]
.Arguments
* `id : ID!`
// end::arguments-tweetSentimentCode[]

// end::query-tweetSentimentCode[]

// tag::query-tweetSentimentACode[]

[[query_tweetsentimentacode]]
=== tweetSentimentACode


// tag::method-description-tweetSentimentACode[]
An example of an internal query.

[source,graphql]
----
tweetSentimentACode(123) {
   Sentiment
}
----

* `id`: An id that are _REQUIRED_
* _RETURNS_ :  a list of Sentiments
// end::method-description-tweetSentimentACode[]

// tag::method-signature-tweetSentimentACode[]
.query: tweetSentimentACode
[source, kotlin]
----
tweetSentimentACode(
  id: `ID!` <1> 
): <<Sentiment,`Sentiment`>> <2>
----
// end::method-signature-tweetSentimentACode[]

// tag::method-args-tweetSentimentACode[]
// end::method-args-tweetSentimentACode[]

// tag::query-name-tweetSentimentACode[]
*Query Name:* _tweetSentimentACode_
// end::query-name-tweetSentimentACode[]

// tag::query-return-tweetSentimentACode[]
*Return:* <<Sentiment,`Sentiment`>>
// end::query-return-tweetSentimentACode[]

// tag::arguments-tweetSentimentACode[]
.Arguments
* `id : ID!`
// end::arguments-tweetSentimentACode[]

// end::query-tweetSentimentACode[]

// tag::query-tweetSentimentDep[]

[[query_tweetsentimentdep]]
=== tweetSentimentDep


// tag::method-description-tweetSentimentDep[]
An example of an internal query.

`@deprecated(reason: "Internal test")`

* `id`: An id that are _REQUIRED_
* _RETURNS_ :  a list of Sentiments
// end::method-description-tweetSentimentDep[]

// tag::method-signature-tweetSentimentDep[]
.query: tweetSentimentDep
[source, kotlin]
----
tweetSentimentDep(
  id: `ID!` <1> 
): <<Sentiment,`Sentiment`>> <2>
----
// end::method-signature-tweetSentimentDep[]

// tag::method-args-tweetSentimentDep[]
// end::method-args-tweetSentimentDep[]

// tag::query-name-tweetSentimentDep[]
*Query Name:* _tweetSentimentDep_
// end::query-name-tweetSentimentDep[]

// tag::query-return-tweetSentimentDep[]
*Return:* <<Sentiment,`Sentiment`>>
// end::query-return-tweetSentimentDep[]

// tag::arguments-tweetSentimentDep[]
.Arguments
* `id : ID!`
// end::arguments-tweetSentimentDep[]

// tag::query-changelog-tweetSentimentDep[]

.Changelog
* add: 1.0.0
* update: 1.2.3, 2.0.5
* deprecated: 2.6.0
* removed: 2.7.8
// end::query-changelog-tweetSentimentDep[]

// end::query-tweetSentimentDep[]

// tag::query-multiCalloutExample[]

[[query_multicalloutexample]]
=== multiCalloutExample


// tag::method-description-multiCalloutExample[]
Advanced query example with multiple callout styles.

[source,javascript]
----
// JavaScript client example
const client = new GraphQLClient(endpoint); <1>

const query = `
  query MultiExample($ids: [ID!]!) { <2>
    tweets: getTweets(ids: $ids) <3>
      .map(tweet => tweet.sentiment) <4>
  }
`;

const result = await client.request(query, {
  ids: ["1", "2", "3"] <5>
});
----

**Callout explanations:**

(1) Initialize the GraphQL client with endpoint
(2) Define the parameterized query with required ID array
(3) Fetch tweets using the provided IDs
(4) Transform results to extract sentiment data
(5) Pass the actual ID values as variables

[NOTE]
====
This demonstrates all supported callout patterns in code blocks.
====
// end::method-description-multiCalloutExample[]

// tag::method-signature-multiCalloutExample[]
.query: multiCalloutExample
[source, kotlin]
----
multiCalloutExample(
  ids: [`ID!`]! <1> 
): [<<Sentiment,`Sentiment`>>] <2>
----
// end::method-signature-multiCalloutExample[]

// tag::method-args-multiCalloutExample[]
// end::method-args-multiCalloutExample[]

// tag::query-name-multiCalloutExample[]
*Query Name:* _multiCalloutExample_
// end::query-name-multiCalloutExample[]

// tag::query-return-multiCalloutExample[]
*Return:* [<<Sentiment,`Sentiment`>>]
// end::query-return-multiCalloutExample[]

// tag::arguments-multiCalloutExample[]
.Arguments
* `ids : [ID!]!`
// end::arguments-multiCalloutExample[]

// end::query-multiCalloutExample[]

// tag::query-searchTweets[]

[[query_searchtweets]]
=== searchTweets


// tag::method-description-searchTweets[]
Example query with table documentation.

This endpoint supports various search parameters:

[options="header"]
|===
| Parameter | Type | Required | Description
| query | String | Yes | Search term to match
| limit | Int | No | Maximum results (default: 20)
| offset | Int | No | Starting position (default: 0)
| sortBy | String | No | Field to sort by
|===

[TIP]
====
Use the limit parameter to control response size.
====

For more advanced queries, see <<advanced-search>>.
// end::method-description-searchTweets[]

// tag::method-signature-searchTweets[]
.query: searchTweets
[source, kotlin]
----
searchTweets(
  query: `String!` , <1> 
  limit: `Int` , <2> 
  offset: `Int` , <3> 
  sortBy: `String` <4> 
): [<<Tweet,`Tweet`>>] <5>
----
// end::method-signature-searchTweets[]

// tag::method-args-searchTweets[]
// end::method-args-searchTweets[]

// tag::query-name-searchTweets[]
*Query Name:* _searchTweets_
// end::query-name-searchTweets[]

// tag::query-return-searchTweets[]
*Return:* [<<Tweet,`Tweet`>>]
// end::query-return-searchTweets[]

// tag::arguments-searchTweets[]
.Arguments
* `query : String!`
* `limit : Int`
* `offset : Int`
* `sortBy : String`
// end::arguments-searchTweets[]

// end::query-searchTweets[]

// tag::query-getConfig[]

[[query_getconfig]]
=== getConfig


// tag::method-description-getConfig[]
Configuration query that preserves existing AsciiDoc table formatting.

Available configuration options:

[options="header"]
|===
| Setting | Default | Description
| timeout | 30s | Request timeout
| retries | 3 | Max retry attempts
| cache | true | Enable response caching
|===

[WARNING]
====
Changing these settings affects all API operations.
====
// end::method-description-getConfig[]

// tag::method-signature-getConfig[]
.query: getConfig
[source, kotlin]
----
getConfig(
): `String` <1>
----
// end::method-signature-getConfig[]

// tag::method-args-getConfig[]
// end::method-args-getConfig[]

// tag::query-name-getConfig[]
*Query Name:* _getConfig_
// end::query-name-getConfig[]

// tag::query-return-getConfig[]
*Return:* `String`
// end::query-return-getConfig[]

// end::query-getConfig[]


// tag::mutation[]
[[mutations]]
== Mutations
The root mutation

GraphQL Mutations are entry points on a GraphQL server that provides write access to our data sources.
// tag::mutation-createTweet[]
[[mutation_create_tweet]]
// tag::method-signature-createTweet[]
=== createTweet
// end::method-signature-createTweet[]

// tag::method-description-createTweet[]
Create a new tweet with validation.

Example implementation pattern:

[source,python]
----
def create_tweet(body: str) -> Tweet:
    # Validate input <1>
    if not body or len(body) > 280: <2>
        raise ValidationError("Invalid tweet body")

    # Create tweet object <3>
    tweet = Tweet.create(
        body=body,
        author=current_user() <4>
    )

    return tweet <5>
----

# 1 * Always validate user input first
# 2 * Check Twitter's character limit
(3) Use the domain model to create the tweet
/* 4 */ Get the authenticated user context
(5) Return the newly created tweet
// end::method-description-createTweet[]

.mutation: createTweet
[source, kotlin]
----
createTweet(  body: `String` <1> ) : <<Tweet,`Tweet`>> <2>
----


// tag::method-args-createTweet[]
Create a new tweet with validation.

Example implementation pattern:

```python
def create_tweet(body: str) -> Tweet:
    # Validate input # 1
    if not body or len(body) > 280: # 2
        raise ValidationError("Invalid tweet body")

    # Create tweet object (3)
    tweet = Tweet.create(
        body=body,
        author=current_user() /* 4 */
    )

    return tweet (5)
```

# 1 - Always validate user input first
# 2 - Check Twitter's character limit
(3) Use the domain model to create the tweet
/* 4 */ Get the authenticated user context
(5) Return the newly created tweet
// end::method-args-createTweet[]

// tag::mutation-name-createTweet[]
*Mutation Name:* _createTweet_
// end::mutation-name-createTweet[]

// tag::mutation-return-createTweet[]
*Return:* <<Tweet,`Tweet`>>
// end::mutation-return-createTweet[]
// tag::arguments-createTweet[]
.Arguments
* `body : `String``

// end::arguments-createTweet[]

// end::mutation-createTweet[]

// tag::mutation-deleteTweet[]
[[mutation_delete_tweet]]
// tag::method-signature-deleteTweet[]
=== deleteTweet
// end::method-signature-deleteTweet[]

// tag::method-description-deleteTweet[]
Delete a tweet
// end::method-description-deleteTweet[]

.mutation: deleteTweet
[source, kotlin]
----
deleteTweet(  id: `ID!` <1> ) : <<Tweet,`Tweet`>> <2>
----


// tag::method-args-deleteTweet[]
Delete a tweet
// end::method-args-deleteTweet[]

// tag::mutation-name-deleteTweet[]
*Mutation Name:* _deleteTweet_
// end::mutation-name-deleteTweet[]

// tag::mutation-return-deleteTweet[]
*Return:* <<Tweet,`Tweet`>>
// end::mutation-return-deleteTweet[]
// tag::arguments-deleteTweet[]
.Arguments
* `id : `ID!``

// end::arguments-deleteTweet[]

// end::mutation-deleteTweet[]

// tag::mutation-markTweetRead[]
[[mutation_mark_tweet_read]]
// tag::method-signature-markTweetRead[]
=== markTweetRead
// end::method-signature-markTweetRead[]

// tag::method-description-markTweetRead[]
Mark a tweet as read
// end::method-description-markTweetRead[]

.mutation: markTweetRead
[source, kotlin]
----
markTweetRead(  id: `ID!` <1> ) : `Boolean` <2>
----


// tag::method-args-markTweetRead[]
Mark a tweet as read
// end::method-args-markTweetRead[]

// tag::mutation-name-markTweetRead[]
*Mutation Name:* _markTweetRead_
// end::mutation-name-markTweetRead[]

// tag::mutation-return-markTweetRead[]
*Return:* `Boolean`
// end::mutation-return-markTweetRead[]
// tag::arguments-markTweetRead[]
.Arguments
* `id : `ID!``

// end::arguments-markTweetRead[]

// end::mutation-markTweetRead[]

// tag::mutation-createMessage[]
[[mutation_create_message]]
// tag::method-signature-createMessage[]
=== createMessage
// end::method-signature-createMessage[]

// tag::method-description-createMessage[]
Create a new message example.
// end::method-description-createMessage[]

.mutation: createMessage
[source, kotlin]
----
createMessage(  input: <<MessageInput,`MessageInput`>> <1> ) : <<Message,`Message`>> <2>
----


// tag::method-args-createMessage[]
Create a new message example.
// end::method-args-createMessage[]

// tag::mutation-name-createMessage[]
*Mutation Name:* _createMessage_
// end::mutation-name-createMessage[]

// tag::mutation-return-createMessage[]
*Return:* <<Message,`Message`>>
// end::mutation-return-createMessage[]
// tag::arguments-createMessage[]
.Arguments
* `input : <<MessageInput,`MessageInput`>>`

// end::arguments-createMessage[]

// end::mutation-createMessage[]

// tag::mutation-createMessageDep[]
[[mutation_create_message_dep]]
// tag::method-signature-createMessageDep[]
=== createMessageDep
// end::method-signature-createMessageDep[]

// tag::method-description-createMessageDep[]
Create a new message example.

`@deprecated(reason: "Internal test")`

* `input` is the input message.
// end::method-description-createMessageDep[]

.mutation: createMessageDep
[source, kotlin]
----
createMessageDep(  input: <<MessageInput,`MessageInput`>> <1> ) : <<Message,`Message`>> <2>
----


// tag::method-args-createMessageDep[]
Create a new message example.

@deprecated(reason: "Internal test")

add.version: 1.0.0
update.version: 1.2.3
update.version: 2.0.5
deprecated.version: 2.6.0
removed.version: 2.7.8

- `input` is the input message.
// end::method-args-createMessageDep[]

// tag::mutation-name-createMessageDep[]
*Mutation Name:* _createMessageDep_
// end::mutation-name-createMessageDep[]

// tag::mutation-return-createMessageDep[]
*Return:* <<Message,`Message`>>
// end::mutation-return-createMessageDep[]
// tag::arguments-createMessageDep[]
.Arguments
* `input : <<MessageInput,`MessageInput`>>`

// end::arguments-createMessageDep[]
// tag::mutation-changelog-createMessageDep[]

.Changelog
* add: 1.0.0
* update: 1.2.3, 2.0.5
* deprecated: 2.6.0
* removed: 2.7.8

// end::mutation-changelog-createMessageDep[]

// end::mutation-createMessageDep[]

// end::mutation[]

// tag::subscription[]
== Subscription
Subscribe to a tweet by `id` and get updates when a comment is added.


 .Arguments:
 * `id`: the id of the tweet.


// tag::subscription-commentAdded[]

[[subscription_commentadded]]
=== commentAdded


// tag::subscription-signature-commentAdded[]
.subscription: commentAdded
[source, kotlin]
----
commentAdded(
  id: `ID!` <1> 
): <<Tweet,`Tweet`>> <2>
----
// end::subscription-signature-commentAdded[]

// tag::subscription-name-commentAdded[]
*Subscription Name:* _commentAdded_
// end::subscription-name-commentAdded[]

// tag::subscription-return-commentAdded[]
*Return:* <<Tweet,`Tweet`>>
// end::subscription-return-commentAdded[]

// tag::subscription-arguments-commentAdded[]
.Arguments
* `id : ID!`
// end::subscription-arguments-commentAdded[]

// end::subscription-commentAdded[]




// end::subscription[]

== Types

// tag::type-CLogExample[]
[[type_c_log_example]]
=== CLogExample
// tag::type-description-CLogExample[]
An example of a type with a changelog in the type definition as well as on the fieds.

// end::type-description-CLogExample[]
// tag::type-changelog-CLogExample[]

.Changelog
* add: 1.0.0
* update: 1.2.3, 2.0.5

// end::type-changelog-CLogExample[]

// tag::type-def-CLogExample[]
.type: CLogExample
[options="header",cols="2a,2m,5a"]
|===
| Type | Field | Description 

| `Int` | count | The total number of items

| `String` | up | This was updated

| `String` | dep | This was deprecated

`@deprecated("testing this out")`


.Changelog
* add: 1.0.0
* update: 1.2.3
* deprecated: 2.6.0


| `String` | new | This was new


.Changelog
* add: 2.6.0

|===

// end::type-def-CLogExample[]

// end::type-CLogExample[]


// tag::type-Message[]
[[type_message]]
=== Message
// tag::type-description-Message[]
A message
// end::type-description-Message[]

// tag::type-def-Message[]
.type: Message
[options="header",cols="2a,2m,5a"]
|===
| Type | Field | Description 

| `String` | content | The message's content

| `String` | author | The message's author
|===

// end::type-def-Message[]

// end::type-Message[]


// tag::type-Meta[]
[[type_meta]]
=== Meta
// tag::type-description-Meta[]
Meta information about the query
// end::type-description-Meta[]

// tag::type-def-Meta[]
.type: Meta
[options="header",cols="2a,2m,5a"]
|===
| Type | Field | Description 

| `Int` | count | The total number of items
|===

// end::type-def-Meta[]

// end::type-Meta[]


// tag::type-Notification[]
[[type_notification]]
=== Notification
// tag::type-description-Notification[]
A notification for a user
// end::type-description-Notification[]

// tag::type-def-Notification[]
.type: Notification
[options="header",cols="2a,2m,5a"]
|===
| Type | Field | Description 

| `ID` | id | The notification ID

| <<Date,`Date`>> | date | The notification date

| `String` | type | The notification type
|===

// end::type-def-Notification[]

// end::type-Notification[]


// tag::type-Stat[]
[[type_stat]]
=== Stat
// tag::type-description-Stat[]
Stats about a tweet, such as number of views, likes, retweets, etc
// end::type-description-Stat[]

// tag::type-def-Stat[]
.type: Stat
[options="header",cols="2a,2m,5a"]
|===
| Type | Field | Description 

| `Int` | views | The number of views

| `Int` | likes | The number of likes

| `Int` | retweets | The number of retweets

| `Int` | responses | The number of responses
|===

// end::type-def-Stat[]

// end::type-Stat[]


// tag::type-Tweet[]
[[type_tweet]]
=== Tweet
// tag::type-description-Tweet[]
A tweet
This schema came from an example found here https://github.com/marmelab/GraphQL-example/blob/master/schema.graphql
// end::type-description-Tweet[]

// tag::type-def-Tweet[]
.type: Tweet
[options="header",cols="2a,2m,5a"]
|===
| Type | Field | Description 

| `ID!` | id | The tweet ID

.Notes:

| `String` | body | The tweet text. No more than 140 characters!

| <<Date,`Date`>> | date | When the tweet was published

| <<User,`User`>> | Author | Who published the tweet

| <<Stat,`Stat`>> | Stats | Views, retweets, likes, etc

| <<Sentiment,`Sentiment`>> | sentiment | The tweet's sentiment

| `String` | newField | This is to test the version number of this field.


.Changelog
* add: 1.0.0
* update: 1.2.3, 2.0.5
* deprecated: 2.6.0
* removed: 2.7.8

|===

// end::type-def-Tweet[]

// end::type-Tweet[]


// tag::type-User[]
[[type_user]]
=== User
// tag::type-description-User[]
A Twitter user. They can publish tweets, and have followers
// end::type-description-User[]

// tag::type-def-User[]
.type: User
[options="header",cols="2a,2m,5a"]
|===
| Type | Field | Description 

| `ID!` | id | The user ID

.Notes:

| `String` | username | The user's Twitter handle

| `String` | first_name | The user's real name

| `String` | last_name | The user's real name

| `String` | full_name | The user's real full name

| `String` | name | The user's name, that is deprecated

| <<Url,`Url`>> | avatar_url | The user's avatar URL
|===

// end::type-def-User[]

// end::type-User[]



== Enums

// tag::enum-Direction[]
[[enum_direction]]

=== Direction
// tag::enum-description-Direction[]
# tag::ENUM_DIRECTION_DES[]

The direction UP or Down

# end::ENUM_DIRECTION_DES[]
// end::enum-description-Direction[]

// tag::enum-def-Direction[]
.enum: Direction
[options="header",cols="1m,3a"]
|===
| Value | Description 
| `UP` | The Up direction.
| `DOWN` | The Down direction.
|===

// end::enum-def-Direction[]

// end::enum-Direction[]


// tag::enum-MutationMode[]
[[enum_mutation_mode]]

=== MutationMode
// tag::enum-description-MutationMode[]
The mode of the mutation.

The mutation can be either `synchronous` or `asynchronous`, depending on if the data requires further processing or not.
// end::enum-description-MutationMode[]

// tag::enum-def-MutationMode[]
.enum: MutationMode
[options="header",cols="1m,3a"]
|===
| Value | Description 
| `SYNC` | Synchronous
| `ASYNC` | Asynchronous
|===

// end::enum-def-MutationMode[]

// end::enum-MutationMode[]


// tag::enum-Sentiment[]
[[enum_sentiment]]

=== Sentiment
// tag::enum-description-Sentiment[]
# tag::SENTIMENT_DES[]
A sentiment enum

.Values
* `HAPPY`: A happy one
* `SAD`: A sad one
* `INDIFFERENT`: An indifferent one
* `OTHER`: Something else

This is just to demonstrate how to document an enum with asciidoc tags in the description.

# end::SENTIMENT_DES[]
// end::enum-description-Sentiment[]

// tag::enum-def-Sentiment[]
.enum: Sentiment
[options="header",cols="1m,3a"]
|===
| Value | Description 
| `HAPPY` | The tweet is happy.
| `SAD` | The tweet is sad.
| `INDIFFERENT` | The tweet is indifferent.
| `OTHER` | The tweet is something else.
|===

// end::enum-def-Sentiment[]

// end::enum-Sentiment[]



== Inputs

// tag::input-CLogExampleInput[]
[[input_c_log_example_input]]
=== CLogExampleInput
// tag::input-description-CLogExampleInput[]
An example of a type with a changelog in the type definition as well as on the fieds.

// end::input-description-CLogExampleInput[]
// tag::input-changelog-CLogExampleInput[]

.Changelog
* add: 1.0.0
* update: 1.2.3, 2.0.5

// end::input-changelog-CLogExampleInput[]

// tag::input-def-CLogExampleInput[]
.input: CLogExampleInput
[options="header",cols="2a,2m,5a"]
|===
| Field | Type | Description 
| `count` | `Int` | The total number of items
| `up` | `String` | This was updated
| `dep` | `String` | This was deprecated

`@deprecated("testing this out")`


.Changelog
* add: 1.0.0
* update: 1.2.3
* deprecated: 2.6.0

| `new` | `String` | This was new


.Changelog
* add: 2.6.0

|===

// end::input-def-CLogExampleInput[]

// end::input-CLogExampleInput[]


// tag::input-DateFilter[]
[[input_date_filter]]
=== DateFilter
// tag::input-description-DateFilter[]
Defines an inclusive time window used to filter records (e.g. delta changes, events, logs) by their timestamps.

.Use Cases:
* **Delta queries**: clients can pass a `DateFilter` to `deltaChanges` (or similar endpoints) to retrieve only
those records whose timestamps fall between two instants.
* **Searches & reporting**: limit results to objects created, updated, or deleted within a specific date/time range.

.Behavior & Validation:
* Both `fromDateTime` and `toDateTime` are **inclusive**. Events occurring exactly at `fromDateTime` or `toDateTime`
should be included.
* `fromDateTime` **must be less than or equal to** `toDateTime`. If a client sends them in reverse order, the server
**should** respond with a validation error stating "fromDateTime must be less than or equal to `toDateTime`".
* Timestamps are expected in the **ISO-8601** format `YYYY-MM-DD'T'HH:mm:ss`.
* Because this input uses the scalar `LocalDateTime`, it does not carry a timezone offset.

.Example JSON representation (as a request payload in REST, or variables in GraphQL):
[source,json]
----
{
  "fromDateTime": "2025-01-01T00:00:00",
  "toDateTime":   "2025-01-01T23:59:59"
}
----
// end::input-description-DateFilter[]

// tag::input-def-DateFilter[]
.input: DateFilter
[options="header",cols="2a,2m,5a"]
|===
| Field | Type | Description 
| `fromDateTime` | `LocalDateTime!` | .**Required:** Inclusive start or lower bound of the date/time window.
* **Format:** ISO-8601 `YYYY-MM-DD'T'HH:mm:ss` (e.g. _2025-01-01T00:00:00_).
* **Constraint:** Must be less than or equal to `toDateTime`.
* Any event whose timestamp is exactly equal to `after` must be included in the result.

.Validation:
* If `after` is missing or not a valid ISO-8601 string, return a validation error: +
`"Invalid ISO8601DateTime format for field 'after'."`

.Examples:
* `2025-05-01T00:00:00` (midnight UTC on May 1, 2025)
* `2025-06-06T14:30:15`
* `2025-06-06T00:00:00Z`
* `2025-06-06T10:00:00+10:00`


If this field is not strictly earlier than or equal to `toDateTime`, the server will reject the request.
| `toDateTime` | `LocalDateTime!` | .An explicit inclusive upper bound orr end of the date/time window.
* **Format:** ISO-8601 YYYY-MM-DD'T'HH:mm:ss (e.g. 2025-05-31T23:59:59).
* **Constraint:** Must be greater than or equal to `fromDateTime`.

Example:
• `2025-05-31T23:59:59` (one second before midnight UTC on May 31, 2025)

If this field is not strictly later than or equal to fromDateTime, the server will reject the request.
|===

// end::input-def-DateFilter[]

// end::input-DateFilter[]


// tag::input-MessageInput[]
[[input_message_input]]
=== MessageInput
// tag::input-description-MessageInput[]
Example of an input type
// end::input-description-MessageInput[]

// tag::input-def-MessageInput[]
.input: MessageInput
[options="header",cols="2a,2m,5a"]
|===
| Field | Type | Description 
| `content` | `String` | The message's content
| `author` | `String` | The message's author
|===

// end::input-def-MessageInput[]

// end::input-MessageInput[]


== Directives

// tag::DIRECTIVES[]

// tag::directive-Size[]

[[directive_size]]
=== @Size

// tag::directive-description-Size[]
Directive to specify the size constraints on arguments and input fields.

.Arguments:
* `min`: min the minimum size allowed, default is 0
* `max`: the maximum size allowed, default is 2147483647
* `message`: the validation message, default is "graphql.validation.Size.message"
// end::directive-description-Size[]

// tag::directive-signature-Size[]
.Directive Signature
[source, graphql]
----
directive @Size(min: Int = 0, max: Int! = 2147483647, message: String = "graphql.validation.Size.message") on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | FIELD_DEFINITION
----
// end::directive-signature-Size[]

// tag::directive-arguments-Size[]
.@Size Arguments
[options="header",stripes="even"]
|===
| Argument | Type | Default | Description
| `min` | `Int` | `0` | _No description_
| `max` | `Int!` | `2147483647` | _No description_
| `message` | `String` | `"graphql.validation.Size.message"` | _No description_
|===
// end::directive-arguments-Size[]

// tag::directive-locations-Size[]
.@Size Usage Locations
* `ARGUMENT_DEFINITION`
* `INPUT_FIELD_DEFINITION`
* `FIELD_DEFINITION`
// end::directive-locations-Size[]

// end::directive-Size[]

// tag::directive-length[]

[[directive_length]]
=== @length

// tag::directive-description-length[]
Directive to specify the length constraints on arguments and input fields.

.Arguments:
* `min`: the minimum length allowed, default is 0
* `max`: the maximum length allowed, default is 2147483647
* `message`: the validation message, default is "graphql.validation.Size.message"
// end::directive-description-length[]

// tag::directive-signature-length[]
.Directive Signature
[source, graphql]
----
directive @length(min: Int = 0, max: Int! = 2147483647, message: String = "graphql.validation.Size.message") on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | FIELD_DEFINITION
----
// end::directive-signature-length[]

// tag::directive-arguments-length[]
.@length Arguments
[options="header",stripes="even"]
|===
| Argument | Type | Default | Description
| `min` | `Int` | `0` | _No description_
| `max` | `Int!` | `2147483647` | _No description_
| `message` | `String` | `"graphql.validation.Size.message"` | _No description_
|===
// end::directive-arguments-length[]

// tag::directive-locations-length[]
.@length Usage Locations
* `ARGUMENT_DEFINITION`
* `INPUT_FIELD_DEFINITION`
* `FIELD_DEFINITION`
// end::directive-locations-length[]

// end::directive-length[]

// end::DIRECTIVES[]

// tag::scalar[]
[[scalars]]
== Scalars

GraphQL specifies a basic set of well-defined Scalar types: Int, Float, String, Boolean, and ID.

The following custom scalar types are defined in this schema:
// tag::scalar-Date[]
[[scalar-Date]]
=== Date

// tag::scalar-description-Date[]
# tag::SCALAR_DATE_DES[]
A date string scalar
# end::SCALAR_DATE_DES[]
// end::scalar-description-Date[]


// end::scalar-Date[]


// tag::scalar-ISO8601DateTime[]
[[scalar-ISO8601DateTime]]
=== ISO8601DateTime

// tag::scalar-description-ISO8601DateTime[]
A custom scalar that enforces full ISO-8601 date‐time strings with time‐zone offsets.

.Example values:
* "2025-06-06T00:00:00Z"
* "2025-06-06T14:30:45+10:00"
* "2025-06-06T18:15:00-05:00"
Internally, this should map to something like java.time.OffsetDateTime
 or java.time.Instant (if you normalize to UTC on parse).
// end::scalar-description-ISO8601DateTime[]


// end::scalar-ISO8601DateTime[]


// tag::scalar-Url[]
[[scalar-Url]]
=== Url

// tag::scalar-description-Url[]
# tag::SCALAR_URL_DES[]
A URL string scalar
# end::SCALAR_URL_DES[]
// end::scalar-description-Url[]


// end::scalar-Url[]


// end::scalar[]
