package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/parser"
)

func main() {
	if len(os.Args) != 2 {
		log.Fatal("Usage: ./program schema.graphql")
	}

	b, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}

	source := &ast.Source{
		Name:  "GraphQL schema",
		Input: string(b),
	}

	doc, gqlErr := parser.ParseSchema(source)
	if gqlErr != nil {
		log.Fatal(gqlErr)
	}

	definitionsMap := make(map[string]*ast.Definition)
	for _, def := range doc.Definitions {
		definitionsMap[def.Name] = def
	}

	// Sort definitions by name
	sortedDefs := make([]*ast.Definition, len(doc.Definitions))
	copy(sortedDefs, doc.Definitions)
	sort.Slice(sortedDefs, func(i, j int) bool {
		return sortedDefs[i].Name < sortedDefs[j].Name
	})

	// Print heading and current time
	fmt.Println("= GraphQL Documentation")
	fmt.Println(":toc: left")
	fmt.Printf(":revdate: %s\n", time.Now().Format(time.RFC1123))
	//fmt.Printf(":commandline: %s\n\n", strings.Join(os.Args, " ")) // Add command line as header attribute

	fmt.Println("\n\n")

	fmt.Println("[IMPORTANT]")
	fmt.Println("====")
	fmt.Println("This is automatically generated from the schema file. +")
	fmt.Println("Do not edit this file directly. +")
	fmt.Println("Last generated _{revdate}_ \n\n")
	fmt.Println("====\n\n\n")

	fmt.Println("== Types\n")
	//for _, t := range doc.Definitions {
	for _, t := range sortedDefs {
		if (t.Kind == ast.Object && t.Name != "Query") || t.Kind == ast.Interface {
			fmt.Printf("[[%s]]\n", t.Name) // Add anchor
			fmt.Printf("=== %s\n\n", t.Name)

			if t.Description != "" {
				printAsciiDocTags(t.Description)
			}

			printObjectFields(t, definitionsMap)

			fmt.Println("\n")
		}
	}

	fmt.Println("== Enumerations\n")
	for _, t := range sortedDefs {
		if t.Kind == ast.Enum {
			fmt.Printf("[[%s]]\n", t.Name) // Add anchor
			fmt.Printf("=== %s\n\n", t.Name)

			if t.Description != "" {
				printAsciiDocTags(t.Description)
			}

			printEnumValues(t)

			fmt.Println("\n")
		}
	}

	fmt.Println("== Query\n")
	for _, t := range sortedDefs {
		if t.Kind == ast.Object && t.Name == "Query" {
			fmt.Printf("[[%s]]\n", t.Name) // Add anchor
			//fmt.Printf("=== %s\n\n", t.Name)

			if t.Description != "" {
				printAsciiDocTags(t.Description)
			}

			printObjectFields(t, definitionsMap)

			fmt.Println("\n")
		}
	}

}

func printObjectFields(t *ast.Definition, definitionsMap map[string]*ast.Definition) {
	if len(t.Fields) > 0 {
		fmt.Println("[cols=\"2a,4a,6a\", options=\"header\"]")
		fmt.Println("|===")
		if t.Name == "Query" {
			fmt.Println("| Return | Function | Description")
		} else {
			fmt.Println("| Type | Name | Description")
		}

		for _, f := range t.Fields {
			typeName := f.Type.String()

			// If the type is a named type (i.e., not a scalar like 'Int' or 'String'), link to it
			if definitionsMap[typeName] != nil && definitionsMap[typeName].Kind == ast.Object {
				typeName = fmt.Sprintf("<<%s,%s>>", typeName, typeName)
			}

			if t.Name == "Query" {
				fmt.Printf("| %s | %s | %s\n", typeName, f.Name, f.Description)
			} else {
				fmt.Printf("| %s | %s | %s\n", typeName, f.Name, f.Description)
			}
		}

		fmt.Println("|===")
	}
}

func printEnumValues(t *ast.Definition) {
	if len(t.EnumValues) > 0 {
		fmt.Println("[cols=\"2*a\", options=\"header\"]")
		fmt.Println("|===")
		fmt.Println("| Value | Description")

		for _, v := range t.EnumValues {
			fmt.Printf("| %s | %s\n", v.Name, v.Description)
		}
		fmt.Println("|===")
	}
}

func printAsciiDocTags(description string) {
	lines := strings.Split(description, "\n")
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "# tag::") || strings.HasPrefix(trimmed, "# end::") {
			fmt.Println(trimmed[1:]) // remove the '#' as AsciiDoc comments start with '//' not '#'
		}
	}
}
